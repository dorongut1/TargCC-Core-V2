# Phase 2: Modern Architecture - ××¤×™×•×Ÿ ××œ× ğŸ—ï¸

**×ª××¨×™×š:** 18/11/2025  
**×’×¨×¡×”:** 2.0  
**×–××Ÿ ××©×•×¢×¨:** 4-5 ×©×‘×•×¢×•×ª (20-25 ×™××™ ×¢×‘×•×“×”)  
**××˜×¨×”:** ×™×¦×™×¨×ª Clean Architecture ××œ××” ×¢× REST API

---

## ğŸ“‹ ×ª×•×›×Ÿ ×¢× ×™×™× ×™×

1. [×¡×§×™×¨×” ×›×œ×œ×™×ª](#×¡×§×™×¨×”-×›×œ×œ×™×ª)
2. [××¨×›×™×˜×§×˜×•×¨×” ××¤×•×¨×˜×ª](#××¨×›×™×˜×§×˜×•×¨×”-××¤×•×¨×˜×ª)
3. [Generators ×©× ×‘× ×”](#generators-×©× ×‘× ×”)
4. [×ª×›× ×•×Ÿ ×©×‘×•×¢×™](#×ª×›× ×•×Ÿ-×©×‘×•×¢×™)
5. [×“×•×’×××•×ª ×§×•×“](#×“×•×’×××•×ª-×§×•×“)
6. [××“×“×™ ×”×¦×œ×—×”](#××“×“×™-×”×¦×œ×—×”)

---

## ğŸ¯ ×¡×§×™×¨×” ×›×œ×œ×™×ª

### ××” ×–×” Phase 2?

**Phase 2 = Modern Architecture Implementation**

```
Phase 1.5 (MVP) âœ…
    â†“
    SQL + Entity Generators
    â†“
Phase 2 (Modern Architecture) â† ×›××Ÿ!
    â†“
    Clean Architecture
    CQRS + MediatR
    REST API
    Repository Pattern
    â†“
Phase 3 (UI + AI)
```

### ××” × ×‘× ×”?

**5 ×¤×¨×•×™×§×˜×™×** (×‘××§×•× 8):

1. **Domain** - Entities + Interfaces (zero dependencies)
2. **Application** - Business Logic (CQRS)
3. **Infrastructure** - Data Access + Services
4. **API** - REST Controllers + Swagger
5. **Tests** - Unit + Integration

---

## ğŸ›ï¸ ××¨×›×™×˜×§×˜×•×¨×” ××¤×•×¨×˜×ª

### ××‘× ×” Solution

```
TargCC.Modern.sln
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ 1. Domain/
â”‚   â”‚   â”œâ”€â”€ Entities/
â”‚   â”‚   â”œâ”€â”€ Enums/
â”‚   â”‚   â”œâ”€â”€ Exceptions/
â”‚   â”‚   â”œâ”€â”€ Common/
â”‚   â”‚   â””â”€â”€ TargCC.Domain.csproj
â”‚   â”‚
â”‚   â”œâ”€â”€ 2. Application/
â”‚   â”‚   â”œâ”€â”€ Features/
â”‚   â”‚   â”œâ”€â”€ Common/
â”‚   â”‚   â”œâ”€â”€ Abstractions/
â”‚   â”‚   â””â”€â”€ TargCC.Application.csproj
â”‚   â”‚
â”‚   â”œâ”€â”€ 3. Infrastructure/
â”‚   â”‚   â”œâ”€â”€ Data/
â”‚   â”‚   â”œâ”€â”€ Repositories/
â”‚   â”‚   â”œâ”€â”€ Services/
â”‚   â”‚   â””â”€â”€ TargCC.Infrastructure.csproj
â”‚   â”‚
â”‚   â””â”€â”€ 4. API/
â”‚       â”œâ”€â”€ Controllers/
â”‚       â”œâ”€â”€ Middleware/
â”‚       â”œâ”€â”€ Filters/
â”‚       â””â”€â”€ TargCC.API.csproj
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ TargCC.Domain.Tests/
    â”œâ”€â”€ TargCC.Application.Tests/
    â”œâ”€â”€ TargCC.Infrastructure.Tests/
    â””â”€â”€ TargCC.API.Tests/
```

---

### 1. Domain Layer ğŸ“¦

**×ª×¤×§×™×“:** Pure business logic, zero dependencies

```
Domain/
â”œâ”€â”€ Entities/                      â† Generated by EntityGenerator âœ…
â”‚   â”œâ”€â”€ Customer.cs
â”‚   â”œâ”€â”€ Order.cs
â”‚   â”œâ”€â”€ OrderItem.cs
â”‚   â””â”€â”€ Product.cs
â”‚
â”œâ”€â”€ Common/
â”‚   â”œâ”€â”€ BaseEntity.cs             â† Base class for all entities
â”‚   â”œâ”€â”€ BaseAuditableEntity.cs    â† With audit fields
â”‚   â””â”€â”€ ValueObject.cs            â† For value objects
â”‚
â”œâ”€â”€ Enums/
â”‚   â”œâ”€â”€ OrderStatus.cs
â”‚   â””â”€â”€ CustomerType.cs
â”‚
â”œâ”€â”€ Exceptions/
â”‚   â”œâ”€â”€ DomainException.cs
â”‚   â””â”€â”€ ValidationException.cs
â”‚
â””â”€â”€ Interfaces/                    â† Generated by RepositoryInterfaceGenerator
    â”œâ”€â”€ IRepository.cs            â† Base repository
    â”œâ”€â”€ ICustomerRepository.cs
    â””â”€â”€ IOrderRepository.cs
```

#### ×“×•×’××”: Customer.cs

```csharp
// Generated by EntityGenerator
namespace TargCC.Domain.Entities;

/// <summary>
/// Customer entity - represents a customer in the system.
/// Generated from table: Customer
/// </summary>
public class Customer : BaseAuditableEntity
{
    // Primary Key
    public int ID { get; set; }
    
    // Regular properties
    public string Name { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
    public string? Phone { get; set; }
    
    // Encrypted property (ent_ prefix)
    private string? _creditCard;
    public string? CreditCard
    {
        get => DecryptValue(_creditCard);
        set => _creditCard = EncryptValue(value);
    }
    
    // Hashed property (eno_ prefix)
    public string? PasswordHashed { get; private set; }
    
    // Lookup property (lkp_ prefix)
    public string? StatusCode { get; set; }
    public string? StatusText { get; set; }
    
    // Aggregate property (agg_ prefix)
    public int OrderCountAggregate { get; private set; }
    public decimal TotalSpentAggregate { get; private set; }
    
    // Navigation properties
    public virtual ICollection<Order> Orders { get; set; } = new List<Order>();
    
    // Methods
    public void SetPassword(string plainTextPassword)
    {
        PasswordHashed = HashPassword(plainTextPassword);
    }
    
    public void UpdateAggregates(int orderCount, decimal totalSpent)
    {
        OrderCountAggregate = orderCount;
        TotalSpentAggregate = totalSpent;
    }
    
    // Helper methods (generated)
    private string? EncryptValue(string? value) => 
        string.IsNullOrEmpty(value) ? null : $"[Encrypted:{value}]";
    
    private string? DecryptValue(string? value) =>
        value?.Replace("[Encrypted:", "").Replace("]", "");
    
    private string HashPassword(string password) =>
        $"[Hashed:{password}]"; // Real implementation uses BCrypt
}
```

---

### 2. Application Layer ğŸ¯

**×ª×¤×§×™×“:** Business Logic, Use Cases (CQRS)

```
Application/
â”œâ”€â”€ Features/                      â† Feature-based organization
â”‚   â”œâ”€â”€ Customers/
â”‚   â”‚   â”œâ”€â”€ Queries/
â”‚   â”‚   â”‚   â”œâ”€â”€ GetCustomer/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ GetCustomerQuery.cs       â† Generated
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ GetCustomerHandler.cs     â† Generated
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ GetCustomerValidator.cs   â† Generated
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ CustomerDto.cs           â† Generated
â”‚   â”‚   â”‚   â”œâ”€â”€ GetCustomers/
â”‚   â”‚   â”‚   â””â”€â”€ GetCustomersByStatus/
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ Commands/
â”‚   â”‚       â”œâ”€â”€ CreateCustomer/
â”‚   â”‚       â”‚   â”œâ”€â”€ CreateCustomerCommand.cs  â† Generated
â”‚   â”‚       â”‚   â”œâ”€â”€ CreateCustomerHandler.cs  â† Generated
â”‚   â”‚       â”‚   â””â”€â”€ CreateCustomerValidator.csâ† Generated
â”‚   â”‚       â”œâ”€â”€ UpdateCustomer/
â”‚   â”‚       â””â”€â”€ DeleteCustomer/
â”‚   â”‚
â”‚   â””â”€â”€ Orders/
â”‚       â”œâ”€â”€ Queries/
â”‚       â””â”€â”€ Commands/
â”‚
â”œâ”€â”€ Common/
â”‚   â”œâ”€â”€ Interfaces/
â”‚   â”‚   â”œâ”€â”€ IApplicationDbContext.cs
â”‚   â”‚   â””â”€â”€ IDateTime.cs
â”‚   â”œâ”€â”€ Behaviors/
â”‚   â”‚   â”œâ”€â”€ ValidationBehavior.cs
â”‚   â”‚   â”œâ”€â”€ LoggingBehavior.cs
â”‚   â”‚   â””â”€â”€ PerformanceBehavior.cs
â”‚   â”œâ”€â”€ Mappings/
â”‚   â”‚   â””â”€â”€ MappingProfile.cs                 â† AutoMapper
â”‚   â””â”€â”€ Models/
â”‚       â”œâ”€â”€ Result.cs
â”‚       â””â”€â”€ PaginatedList.cs
â”‚
â””â”€â”€ Abstractions/
    â””â”€â”€ IQuery.cs
    â””â”€â”€ ICommand.cs
```

#### ×“×•×’××”: GetCustomerQuery

```csharp
// Generated by QueryGenerator
namespace TargCC.Application.Features.Customers.Queries.GetCustomer;

/// <summary>
/// Query to get a customer by ID.
/// </summary>
public record GetCustomerQuery(int Id) : IRequest<Result<CustomerDto>>;

/// <summary>
/// DTO for Customer response.
/// </summary>
public class CustomerDto
{
    public int ID { get; init; }
    public string Name { get; init; } = string.Empty;
    public string Email { get; init; } = string.Empty;
    public string? Phone { get; init; }
    public string? StatusText { get; init; }
    public int OrderCount { get; init; }
    public decimal TotalSpent { get; init; }
}

/// <summary>
/// Handler for GetCustomerQuery.
/// Uses Repository pattern for data access.
/// </summary>
public class GetCustomerHandler : IRequestHandler<GetCustomerQuery, Result<CustomerDto>>
{
    private readonly ICustomerRepository _repository;
    private readonly IMapper _mapper;
    private readonly ILogger<GetCustomerHandler> _logger;

    public GetCustomerHandler(
        ICustomerRepository repository,
        IMapper mapper,
        ILogger<GetCustomerHandler> logger)
    {
        _repository = repository;
        _mapper = mapper;
        _logger = logger;
    }

    public async Task<Result<CustomerDto>> Handle(
        GetCustomerQuery request, 
        CancellationToken cancellationToken)
    {
        _logger.LogInformation("Getting customer {CustomerId}", request.Id);

        var customer = await _repository.GetByIdAsync(request.Id, cancellationToken);

        if (customer is null)
        {
            return Result<CustomerDto>.Failure("Customer not found");
        }

        var dto = _mapper.Map<CustomerDto>(customer);

        return Result<CustomerDto>.Success(dto);
    }
}

/// <summary>
/// Validator for GetCustomerQuery.
/// </summary>
public class GetCustomerValidator : AbstractValidator<GetCustomerQuery>
{
    public GetCustomerValidator()
    {
        RuleFor(x => x.Id)
            .GreaterThan(0)
            .WithMessage("Customer ID must be greater than 0");
    }
}
```

#### ×“×•×’××”: CreateCustomerCommand

```csharp
// Generated by CommandGenerator
namespace TargCC.Application.Features.Customers.Commands.CreateCustomer;

/// <summary>
/// Command to create a new customer.
/// </summary>
public record CreateCustomerCommand : IRequest<Result<int>>
{
    public string Name { get; init; } = string.Empty;
    public string Email { get; init; } = string.Empty;
    public string? Phone { get; init; }
    public string? Password { get; init; }
    public string? StatusCode { get; init; }
}

/// <summary>
/// Handler for CreateCustomerCommand.
/// </summary>
public class CreateCustomerHandler : IRequestHandler<CreateCustomerCommand, Result<int>>
{
    private readonly ICustomerRepository _repository;
    private readonly ILogger<CreateCustomerHandler> _logger;

    public CreateCustomerHandler(
        ICustomerRepository repository,
        ILogger<CreateCustomerHandler> logger)
    {
        _repository = repository;
        _logger = logger;
    }

    public async Task<Result<int>> Handle(
        CreateCustomerCommand request, 
        CancellationToken cancellationToken)
    {
        _logger.LogInformation("Creating customer {CustomerName}", request.Name);

        // Create entity
        var customer = new Customer
        {
            Name = request.Name,
            Email = request.Email,
            Phone = request.Phone,
            StatusCode = request.StatusCode
        };

        // Set password if provided
        if (!string.IsNullOrEmpty(request.Password))
        {
            customer.SetPassword(request.Password);
        }

        // Add to repository
        await _repository.AddAsync(customer, cancellationToken);

        _logger.LogInformation("Customer created with ID {CustomerId}", customer.ID);

        return Result<int>.Success(customer.ID);
    }
}

/// <summary>
/// Validator for CreateCustomerCommand.
/// </summary>
public class CreateCustomerValidator : AbstractValidator<CreateCustomerCommand>
{
    public CreateCustomerValidator()
    {
        RuleFor(x => x.Name)
            .NotEmpty().WithMessage("Name is required")
            .MaximumLength(100).WithMessage("Name must not exceed 100 characters");

        RuleFor(x => x.Email)
            .NotEmpty().WithMessage("Email is required")
            .EmailAddress().WithMessage("Invalid email format")
            .MaximumLength(100).WithMessage("Email must not exceed 100 characters");

        RuleFor(x => x.Phone)
            .MaximumLength(20).WithMessage("Phone must not exceed 20 characters")
            .When(x => !string.IsNullOrEmpty(x.Phone));

        RuleFor(x => x.Password)
            .MinimumLength(8).WithMessage("Password must be at least 8 characters")
            .When(x => !string.IsNullOrEmpty(x.Password));
    }
}
```

---

### 3. Infrastructure Layer ğŸ”§

**×ª×¤×§×™×“:** Data Access, External Services

```
Infrastructure/
â”œâ”€â”€ Data/
â”‚   â”œâ”€â”€ ApplicationDbContext.cs           â† EF Core context
â”‚   â”œâ”€â”€ Configurations/                    â† Entity configurations
â”‚   â”‚   â”œâ”€â”€ CustomerConfiguration.cs
â”‚   â”‚   â””â”€â”€ OrderConfiguration.cs
â”‚   â””â”€â”€ Migrations/                        â† EF Migrations
â”‚
â”œâ”€â”€ Repositories/                          â† Generated
â”‚   â”œâ”€â”€ CustomerRepository.cs
â”‚   â”œâ”€â”€ OrderRepository.cs
â”‚   â””â”€â”€ BaseRepository.cs
â”‚
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ DateTimeService.cs
â”‚   â”œâ”€â”€ EmailService.cs
â”‚   â””â”€â”€ StorageService.cs
â”‚
â””â”€â”€ Sql/
    â”œâ”€â”€ StoredProcedures/                  â† Generated by SqlGenerator âœ…
    â”‚   â”œâ”€â”€ SP_GetCustomerByID.sql
    â”‚   â”œâ”€â”€ SP_UpdateCustomer.sql
    â”‚   â””â”€â”€ SP_DeleteCustomer.sql
    â””â”€â”€ Scripts/
        â””â”€â”€ InitialData.sql
```

#### ×“×•×’××”: CustomerRepository.cs

```csharp
// Generated by RepositoryGenerator
namespace TargCC.Infrastructure.Repositories;

/// <summary>
/// Repository for Customer entity.
/// Uses Dapper for performance-critical operations.
/// </summary>
public class CustomerRepository : ICustomerRepository
{
    private readonly ApplicationDbContext _context;
    private readonly IDbConnection _connection;
    private readonly ILogger<CustomerRepository> _logger;

    public CustomerRepository(
        ApplicationDbContext context,
        ILogger<CustomerRepository> logger)
    {
        _context = context;
        _connection = context.Database.GetDbConnection();
        _logger = logger;
    }

    /// <summary>
    /// Get customer by ID using Stored Procedure.
    /// </summary>
    public async Task<Customer?> GetByIdAsync(int id, CancellationToken cancellationToken = default)
    {
        _logger.LogDebug("Getting customer {CustomerId}", id);

        // Use Dapper + SP for performance
        var customer = await _connection.QueryFirstOrDefaultAsync<Customer>(
            sql: "SP_GetCustomerByID",
            param: new { ID = id },
            commandType: CommandType.StoredProcedure);

        return customer;
    }

    /// <summary>
    /// Get all customers with optional filtering and paging.
    /// </summary>
    public async Task<IEnumerable<Customer>> GetAllAsync(
        string? statusCode = null,
        int? skip = null,
        int? take = null,
        CancellationToken cancellationToken = default)
    {
        var query = _context.Customers.AsQueryable();

        // Filter by status if provided
        if (!string.IsNullOrEmpty(statusCode))
        {
            query = query.Where(c => c.StatusCode == statusCode);
        }

        // Paging
        if (skip.HasValue)
        {
            query = query.Skip(skip.Value);
        }

        if (take.HasValue)
        {
            query = query.Take(take.Value);
        }

        return await query.ToListAsync(cancellationToken);
    }

    /// <summary>
    /// Add new customer using Stored Procedure.
    /// </summary>
    public async Task AddAsync(Customer customer, CancellationToken cancellationToken = default)
    {
        _logger.LogDebug("Adding customer {CustomerName}", customer.Name);

        // Use Dapper + SP
        var id = await _connection.ExecuteScalarAsync<int>(
            sql: "SP_CreateCustomer",
            param: new
            {
                customer.Name,
                customer.Email,
                customer.Phone,
                customer.PasswordHashed,
                customer.StatusCode
            },
            commandType: CommandType.StoredProcedure);

        customer.ID = id;
    }

    /// <summary>
    /// Update customer using Stored Procedure.
    /// </summary>
    public async Task UpdateAsync(Customer customer, CancellationToken cancellationToken = default)
    {
        _logger.LogDebug("Updating customer {CustomerId}", customer.ID);

        await _connection.ExecuteAsync(
            sql: "SP_UpdateCustomer",
            param: new
            {
                customer.ID,
                customer.Name,
                customer.Email,
                customer.Phone,
                customer.StatusCode
            },
            commandType: CommandType.StoredProcedure);
    }

    /// <summary>
    /// Delete customer using Stored Procedure.
    /// </summary>
    public async Task DeleteAsync(int id, CancellationToken cancellationToken = default)
    {
        _logger.LogDebug("Deleting customer {CustomerId}", id);

        await _connection.ExecuteAsync(
            sql: "SP_DeleteCustomer",
            param: new { ID = id },
            commandType: CommandType.StoredProcedure);
    }

    /// <summary>
    /// Check if customer exists.
    /// </summary>
    public async Task<bool> ExistsAsync(int id, CancellationToken cancellationToken = default)
    {
        return await _context.Customers
            .AnyAsync(c => c.ID == id, cancellationToken);
    }

    /// <summary>
    /// Update customer aggregates.
    /// </summary>
    public async Task UpdateAggregatesAsync(
        int id, 
        int orderCount, 
        decimal totalSpent, 
        CancellationToken cancellationToken = default)
    {
        await _connection.ExecuteAsync(
            sql: "SP_UpdateCustomerAggregates",
            param: new
            {
                ID = id,
                agg_OrderCount = orderCount,
                agg_TotalSpent = totalSpent
            },
            commandType: CommandType.StoredProcedure);
    }
}
```

---

### 4. API Layer ğŸŒ

**×ª×¤×§×™×“:** REST API, Controllers, Swagger

```
API/
â”œâ”€â”€ Controllers/                           â† Generated
â”‚   â”œâ”€â”€ CustomersController.cs
â”‚   â”œâ”€â”€ OrdersController.cs
â”‚   â””â”€â”€ BaseApiController.cs
â”‚
â”œâ”€â”€ Middleware/
â”‚   â”œâ”€â”€ ExceptionHandlingMiddleware.cs
â”‚   â”œâ”€â”€ RequestLoggingMiddleware.cs
â”‚   â””â”€â”€ PerformanceMiddleware.cs
â”‚
â”œâ”€â”€ Filters/
â”‚   â”œâ”€â”€ ApiExceptionFilterAttribute.cs
â”‚   â””â”€â”€ ValidateModelAttribute.cs
â”‚
â”œâ”€â”€ Extensions/
â”‚   â””â”€â”€ ServiceCollectionExtensions.cs
â”‚
â””â”€â”€ Program.cs                             â† Entry point
```

#### ×“×•×’××”: CustomersController.cs

```csharp
// Generated by ApiControllerGenerator
namespace TargCC.API.Controllers;

/// <summary>
/// API endpoints for Customer management.
/// </summary>
[ApiController]
[Route("api/[controller]")]
[Produces("application/json")]
public class CustomersController : BaseApiController
{
    private readonly IMediator _mediator;
    private readonly ILogger<CustomersController> _logger;

    public CustomersController(
        IMediator mediator,
        ILogger<CustomersController> logger)
    {
        _mediator = mediator;
        _logger = logger;
    }

    /// <summary>
    /// Get customer by ID.
    /// </summary>
    /// <param name="id">Customer ID</param>
    /// <returns>Customer details</returns>
    [HttpGet("{id}")]
    [ProducesResponseType(typeof(CustomerDto), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> GetCustomer(int id)
    {
        var query = new GetCustomerQuery(id);
        var result = await _mediator.Send(query);

        return result.IsSuccess
            ? Ok(result.Data)
            : NotFound(result.Error);
    }

    /// <summary>
    /// Get all customers with optional filtering.
    /// </summary>
    /// <param name="statusCode">Filter by status (optional)</param>
    /// <param name="pageNumber">Page number (default: 1)</param>
    /// <param name="pageSize">Page size (default: 10)</param>
    /// <returns>List of customers</returns>
    [HttpGet]
    [ProducesResponseType(typeof(PaginatedList<CustomerDto>), StatusCodes.Status200OK)]
    public async Task<IActionResult> GetCustomers(
        [FromQuery] string? statusCode = null,
        [FromQuery] int pageNumber = 1,
        [FromQuery] int pageSize = 10)
    {
        var query = new GetCustomersQuery(statusCode, pageNumber, pageSize);
        var result = await _mediator.Send(query);

        return Ok(result.Data);
    }

    /// <summary>
    /// Create a new customer.
    /// </summary>
    /// <param name="command">Customer details</param>
    /// <returns>Created customer ID</returns>
    [HttpPost]
    [ProducesResponseType(typeof(int), StatusCodes.Status201Created)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    public async Task<IActionResult> CreateCustomer([FromBody] CreateCustomerCommand command)
    {
        var result = await _mediator.Send(command);

        return result.IsSuccess
            ? CreatedAtAction(nameof(GetCustomer), new { id = result.Data }, result.Data)
            : BadRequest(result.Error);
    }

    /// <summary>
    /// Update an existing customer.
    /// </summary>
    /// <param name="id">Customer ID</param>
    /// <param name="command">Updated customer details</param>
    /// <returns>No content</returns>
    [HttpPut("{id}")]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> UpdateCustomer(int id, [FromBody] UpdateCustomerCommand command)
    {
        if (id != command.Id)
        {
            return BadRequest("ID mismatch");
        }

        var result = await _mediator.Send(command);

        return result.IsSuccess
            ? NoContent()
            : NotFound(result.Error);
    }

    /// <summary>
    /// Delete a customer.
    /// </summary>
    /// <param name="id">Customer ID</param>
    /// <returns>No content</returns>
    [HttpDelete("{id}")]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> DeleteCustomer(int id)
    {
        var command = new DeleteCustomerCommand(id);
        var result = await _mediator.Send(command);

        return result.IsSuccess
            ? NoContent()
            : NotFound(result.Error);
    }

    /// <summary>
    /// Get customer orders.
    /// </summary>
    /// <param name="id">Customer ID</param>
    /// <returns>List of orders</returns>
    [HttpGet("{id}/orders")]
    [ProducesResponseType(typeof(IEnumerable<OrderDto>), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> GetCustomerOrders(int id)
    {
        var query = new GetCustomerOrdersQuery(id);
        var result = await _mediator.Send(query);

        return result.IsSuccess
            ? Ok(result.Data)
            : NotFound(result.Error);
    }
}
```

---

## ğŸ¤– Generators ×©× ×‘× ×”

### ×¡×™×›×•× ×›×œ ×”-Generators:

| # | Generator | Input | Output | ×–××Ÿ |
|---|-----------|-------|--------|-----|
| 1 | **EntityGenerator** | Table | Customer.cs | âœ… ×§×™×™× |
| 2 | **SqlGenerator** | Table | SP_*.sql | âœ… ×§×™×™× |
| 3 | **RepositoryInterfaceGenerator** | Table | ICustomerRepository.cs | ğŸ†• |
| 4 | **RepositoryGenerator** | Table | CustomerRepository.cs | ğŸ†• |
| 5 | **QueryGenerator** | Table | GetCustomerQuery + Handler | ğŸ†• |
| 6 | **CommandGenerator** | Table | CreateCustomerCommand + Handler | ğŸ†• |
| 7 | **ValidatorGenerator** | Command/Query | Validators | ğŸ†• |
| 8 | **DtoGenerator** | Entity | CustomerDto | ğŸ†• |
| 9 | **ApiControllerGenerator** | Table | CustomersController.cs | ğŸ†• |
| 10 | **DbContextGenerator** | Schema | ApplicationDbContext.cs | ğŸ†• |

---

### Generator 3: RepositoryInterfaceGenerator

```csharp
// Generated code:
public interface ICustomerRepository
{
    Task<Customer?> GetByIdAsync(int id, CancellationToken cancellationToken = default);
    Task<IEnumerable<Customer>> GetAllAsync(
        string? statusCode = null,
        int? skip = null,
        int? take = null,
        CancellationToken cancellationToken = default);
    Task AddAsync(Customer customer, CancellationToken cancellationToken = default);
    Task UpdateAsync(Customer customer, CancellationToken cancellationToken = default);
    Task DeleteAsync(int id, CancellationToken cancellationToken = default);
    Task<bool> ExistsAsync(int id, CancellationToken cancellationToken = default);
    Task UpdateAggregatesAsync(int id, int orderCount, decimal totalSpent, CancellationToken cancellationToken = default);
}
```

**Logic:**
1. Analyze table structure
2. Generate CRUD methods
3. Add aggregate methods (if agg_ columns exist)
4. Add special methods (for spt_ columns)

---

### Generator 4: RepositoryGenerator

**Template:**
```csharp
public class {TableName}Repository : I{TableName}Repository
{
    private readonly ApplicationDbContext _context;
    private readonly IDbConnection _connection;
    
    // CRUD methods using Dapper + SPs
    // GetByIdAsync â†’ SP_Get{TableName}ByID
    // AddAsync â†’ SP_Create{TableName}
    // UpdateAsync â†’ SP_Update{TableName}
    // DeleteAsync â†’ SP_Delete{TableName}
}
```

---

### Generator 5: QueryGenerator

**Input:** Table + Query Type (GetById, GetAll, GetByIndex)

**Output:**
```csharp
// 1. Query
public record Get{TableName}Query(int Id) : IRequest<Result<{TableName}Dto>>;

// 2. Handler
public class Get{TableName}Handler : IRequestHandler<Get{TableName}Query, Result<{TableName}Dto>>
{
    public async Task<Result<{TableName}Dto>> Handle(...)
    {
        var entity = await _repository.GetByIdAsync(request.Id);
        var dto = _mapper.Map<{TableName}Dto>(entity);
        return Result.Success(dto);
    }
}

// 3. Validator
public class Get{TableName}Validator : AbstractValidator<Get{TableName}Query>
{
    public Get{TableName}Validator()
    {
        RuleFor(x => x.Id).GreaterThan(0);
    }
}
```

---

### Generator 6: CommandGenerator

**Input:** Table + Command Type (Create, Update, Delete)

**Output:** Command + Handler + Validator

---

### Generator 7: ValidatorGenerator

**Logic:**
- NOT NULL columns â†’ `.NotEmpty()`
- MaxLength â†’ `.MaximumLength(n)`
- Email columns â†’ `.EmailAddress()`
- Phone columns â†’ `.Matches(regex)`
- eno_ columns â†’ `.MinimumLength(8)`

---

### Generator 8: DtoGenerator

```csharp
public class CustomerDto
{
    public int ID { get; init; }
    public string Name { get; init; } = string.Empty;
    // ... all properties (no eno_, ent_ exposed!)
}
```

---

### Generator 9: ApiControllerGenerator

**Template:**
```csharp
[ApiController]
[Route("api/[controller]")]
public class {TableName}sController : BaseApiController
{
    [HttpGet("{id}")]
    public async Task<IActionResult> Get{TableName}(int id) { ... }
    
    [HttpGet]
    public async Task<IActionResult> Get{TableName}s(...) { ... }
    
    [HttpPost]
    public async Task<IActionResult> Create{TableName}(...) { ... }
    
    [HttpPut("{id}")]
    public async Task<IActionResult> Update{TableName}(...) { ... }
    
    [HttpDelete("{id}")]
    public async Task<IActionResult> Delete{TableName}(int id) { ... }
}
```

---

### Generator 10: DbContextGenerator

```csharp
public class ApplicationDbContext : DbContext
{
    public DbSet<Customer> Customers { get; set; } = null!;
    public DbSet<Order> Orders { get; set; } = null!;
    // ... all entities
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());
    }
}
```

---

## ğŸ“… ×ª×›× ×™×ª ×¢×‘×•×“×” ×©×‘×•×¢×™×ª

### ğŸ—“ï¸ ×©×‘×•×¢ 1: Repository Pattern (5 ×™××™×)

#### ×™×•× 1: RepositoryInterfaceGenerator

**××” × ×¢×©×”:**
- [ ] ×™×¦×™×¨×ª `IRepositoryInterfaceGenerator`
- [ ] Template ×œ-IRepository
- [ ] CRUD methods generation
- [ ] Aggregate methods (agg_)
- [ ] Special methods (spt_)
- [ ] Tests: 10+

**Output ×“×•×’××”:**
```csharp
public interface ICustomerRepository
{
    Task<Customer?> GetByIdAsync(int id, CancellationToken ct = default);
    Task<IEnumerable<Customer>> GetAllAsync(...);
    Task AddAsync(Customer entity, CancellationToken ct = default);
    Task UpdateAsync(Customer entity, CancellationToken ct = default);
    Task DeleteAsync(int id, CancellationToken ct = default);
    Task<bool> ExistsAsync(int id, CancellationToken ct = default);
}
```

**×–××Ÿ:** 1 ×™×•×

---

#### ×™×•× 2-3: RepositoryGenerator

**××” × ×¢×©×”:**
- [ ] ×™×¦×™×¨×ª `IRepositoryGenerator`
- [ ] Template ×œ-Repository
- [ ] Dapper integration
- [ ] SP calls generation
- [ ] Error handling
- [ ] Logging
- [ ] Tests: 15+

**Output ×“×•×’××”:**
```csharp
public class CustomerRepository : ICustomerRepository
{
    private readonly IDbConnection _connection;
    
    public async Task<Customer?> GetByIdAsync(int id, CancellationToken ct = default)
    {
        return await _connection.QueryFirstOrDefaultAsync<Customer>(
            "SP_GetCustomerByID",
            new { ID = id },
            commandType: CommandType.StoredProcedure);
    }
}
```

**×–××Ÿ:** 2 ×™××™×

---

#### ×™×•× 4-5: DbContextGenerator + Integration

**××” × ×¢×©×”:**
- [ ] ×™×¦×™×¨×ª `IDbContextGenerator`
- [ ] DbContext template
- [ ] DbSet properties
- [ ] Configuration classes
- [ ] Integration tests
- [ ] Tests: 10+

**×–××Ÿ:** 2 ×™××™×

---

### ğŸ—“ï¸ ×©×‘×•×¢ 2: CQRS + MediatR (5 ×™××™×)

#### ×™×•× 1-2: QueryGenerator

**××” × ×¢×©×”:**
- [ ] ×™×¦×™×¨×ª `IQueryGenerator`
- [ ] Query templates (GetById, GetAll, GetByIndex)
- [ ] Handler templates
- [ ] Validator templates
- [ ] DTO integration
- [ ] Tests: 20+

**×–××Ÿ:** 2 ×™××™×

---

#### ×™×•× 3-4: CommandGenerator

**××” × ×¢×©×”:**
- [ ] ×™×¦×™×¨×ª `ICommandGenerator`
- [ ] Command templates (Create, Update, Delete)
- [ ] Handler templates
- [ ] Validator templates
- [ ] Tests: 20+

**×–××Ÿ:** 2 ×™××™×

---

#### ×™×•× 5: DtoGenerator + ValidatorGenerator

**××” × ×¢×©×”:**
- [ ] `IDtoGenerator`
- [ ] `IValidatorGenerator`
- [ ] FluentValidation rules
- [ ] Tests: 15+

**×–××Ÿ:** 1 ×™×•×

---

### ğŸ—“ï¸ ×©×‘×•×¢ 3: API Layer (5 ×™××™×)

#### ×™×•× 1-3: ApiControllerGenerator

**××” × ×¢×©×”:**
- [ ] ×™×¦×™×¨×ª `IApiControllerGenerator`
- [ ] Controller template
- [ ] HTTP verbs (GET, POST, PUT, DELETE)
- [ ] Swagger annotations
- [ ] Error handling
- [ ] Tests: 20+

**×–××Ÿ:** 3 ×™××™×

---

#### ×™×•× 4: Middleware & Filters

**××” × ×¢×©×”:**
- [ ] ExceptionHandlingMiddleware
- [ ] RequestLoggingMiddleware
- [ ] ValidationFilter
- [ ] Tests: 10+

**×–××Ÿ:** 1 ×™×•×

---

#### ×™×•× 5: Program.cs + DI Setup

**××” × ×¢×©×”:**
- [ ] ServiceCollectionExtensions
- [ ] DI registration
- [ ] Swagger configuration
- [ ] CORS setup
- [ ] Tests: 5+

**×–××Ÿ:** 1 ×™×•×

---

### ğŸ—“ï¸ ×©×‘×•×¢ 4: Integration & Testing (5 ×™××™×)

#### ×™×•× 1-2: End-to-End Tests

**××” × ×¢×©×”:**
- [ ] Full integration tests
- [ ] API tests (all endpoints)
- [ ] Database tests
- [ ] Performance tests

**×–××Ÿ:** 2 ×™××™×

---

#### ×™×•× 3-4: Documentation

**××” × ×¢×©×”:**
- [ ] API documentation (Swagger)
- [ ] README updates
- [ ] Architecture diagrams
- [ ] Code examples

**×–××Ÿ:** 2 ×™××™×

---

#### ×™×•× 5: Polish & Release

**××” × ×¢×©×”:**
- [ ] Code review
- [ ] Bug fixes
- [ ] Performance optimization
- [ ] Tag: v2.0.0-rc1

**×–××Ÿ:** 1 ×™×•×

---

## ğŸ“Š ××“×“×™ ×”×¦×œ×—×”

### Functional Requirements:

- âœ… ×™×•×¦×¨ Repository ×¢×‘×•×¨ ×›×œ Entity
- âœ… ×™×•×¦×¨ Query + Command ×¢×‘×•×¨ ×›×œ ×¤×¢×•×œ×”
- âœ… ×™×•×¦×¨ API Controller ×¢×‘×•×¨ ×›×œ Entity
- âœ… Build ×¢×•×‘×¨ ×œ×œ× ×©×’×™××•×ª
- âœ… All tests passing (150+ tests)
- âœ… Swagger documentation complete

### Quality Requirements:

| ××“×“ | ×™×¢×“ | ××“×™×“×” |
|-----|-----|-------|
| **Code Coverage** | 80%+ | xUnit Coverage |
| **SonarQube Grade** | A | SonarQube Analysis |
| **API Response Time** | <50ms | Performance tests |
| **Build Time** | <30s | CI/CD metrics |
| **Documentation** | 100% | XML Comments |

---

## ğŸ¯ ×¡×™×›×•× Phase 2

**××” ×¢×©×™× ×•:**
- âœ… Clean Architecture (5 layers)
- âœ… CQRS + MediatR
- âœ… Repository Pattern
- âœ… REST API + Swagger
- âœ… 10 Generators ×—×“×©×™×
- âœ… 150+ Tests

**×ª×•×¦××”:**
```
Input: Customer table (from DB)
Output:
  âœ… Customer.cs (Domain)
  âœ… ICustomerRepository.cs (Domain)
  âœ… CustomerRepository.cs (Infrastructure)
  âœ… GetCustomerQuery + Handler (Application)
  âœ… CreateCustomerCommand + Handler (Application)
  âœ… CustomersController.cs (API)
  âœ… SP_*.sql (Infrastructure)
  âœ… 20+ Tests

â†’ Full CRUD API ready in minutes! ğŸš€
```

**×”×‘×:** Phase 3 - React UI + AI Features!

---

**×ª××¨×™×š ×™×¦×™×¨×”:** 18/11/2025  
**×’×¨×¡×”:** 1.0  
**×¡×˜×˜×•×¡:** ×××•×©×¨ ×•××•×›×Ÿ ×œ×™×™×©×•×

**ğŸ“š ×§×™×©×•×¨×™×:**
- [Architecture Decision](ARCHITECTURE_DECISION.md)
- [Phase 3 - Advanced Features](PHASE3_ADVANCED_FEATURES.md)
- [Project Roadmap](PROJECT_ROADMAP.md)
