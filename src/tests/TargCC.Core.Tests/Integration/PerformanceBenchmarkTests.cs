// <auto-generated>
// This code was generated by TargCC Code Generator.
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

using System.Diagnostics;
using FluentAssertions;
using Microsoft.Extensions.Logging;
using Moq;
using TargCC.Core.Generators.Data;
using TargCC.Core.Generators.Repositories;
using TargCC.Core.Interfaces.Models;
using TargCC.Core.Tests.TestHelpers;
using Xunit;
using Xunit.Abstractions;

namespace TargCC.Core.Tests.Integration;

/// <summary>
/// Performance benchmark tests for all generators.
/// </summary>
public class PerformanceBenchmarkTests : IntegrationTestBase
{
    private readonly ITestOutputHelper _output;
    private readonly IRepositoryInterfaceGenerator _repositoryInterfaceGenerator;
    private readonly IRepositoryGenerator _repositoryGenerator;
    private readonly IDbContextGenerator _dbContextGenerator;
    private readonly IEntityConfigurationGenerator _entityConfigurationGenerator;

    public PerformanceBenchmarkTests(ITestOutputHelper output)
    {
        _output = output;
        
        _repositoryInterfaceGenerator = new RepositoryInterfaceGenerator(RepoInterfaceLogger);
        _repositoryGenerator = new RepositoryGenerator(RepoLogger);
        _dbContextGenerator = new DbContextGenerator(DbContextLogger);
        _entityConfigurationGenerator = new EntityConfigurationGenerator(EntityConfigLogger);
    }

    [Fact]
    public async Task Benchmark_RepositoryInterfaceGenerator_SimpleTable()
    {
        // Arrange
        var table = CreateTestTable("Customer");
        var stopwatch = new Stopwatch();

        // Act
        stopwatch.Start();
        var code = await _repositoryInterfaceGenerator.GenerateAsync(table);
        stopwatch.Stop();

        // Assert
        stopwatch.ElapsedMilliseconds.Should().BeLessThan(100,
            "RepositoryInterfaceGenerator should complete in under 100ms");

        _output.WriteLine($"RepositoryInterfaceGenerator (Simple): {stopwatch.ElapsedMilliseconds}ms");
        _output.WriteLine($"Generated {code.Length} characters");
    }

    [Fact]
    public async Task Benchmark_RepositoryGenerator_SimpleTable()
    {
        // Arrange
        var table = CreateTestTable("Customer");
        var stopwatch = new Stopwatch();

        // Act
        stopwatch.Start();
        var code = await _repositoryGenerator.GenerateAsync(table);
        stopwatch.Stop();

        // Assert
        stopwatch.ElapsedMilliseconds.Should().BeLessThan(200,
            "RepositoryGenerator should complete in under 200ms");

        _output.WriteLine($"RepositoryGenerator (Simple): {stopwatch.ElapsedMilliseconds}ms");
        _output.WriteLine($"Generated {code.Length} characters");
    }

    [Fact]
    public async Task Benchmark_DbContextGenerator_SmallSchema()
    {
        // Arrange
        var schema = CreateTestSchema(); // 2 tables
        var stopwatch = new Stopwatch();

        // Act
        stopwatch.Start();
        var code = await _dbContextGenerator.GenerateAsync(schema);
        stopwatch.Stop();

        // Assert
        stopwatch.ElapsedMilliseconds.Should().BeLessThan(100,
            "DbContextGenerator should complete in under 100ms for small schema");

        _output.WriteLine($"DbContextGenerator (2 tables): {stopwatch.ElapsedMilliseconds}ms");
        _output.WriteLine($"Generated {code.Length} characters");
    }

    [Fact]
    public async Task Benchmark_EntityConfigurationGenerator_SimpleTable()
    {
        // Arrange
        var table = CreateTestTable("Customer");
        var stopwatch = new Stopwatch();

        // Act
        stopwatch.Start();
        var code = await _entityConfigurationGenerator.GenerateAsync(table);
        stopwatch.Stop();

        // Assert
        stopwatch.ElapsedMilliseconds.Should().BeLessThan(150,
            "EntityConfigurationGenerator should complete in under 150ms");

        _output.WriteLine($"EntityConfigurationGenerator (Simple): {stopwatch.ElapsedMilliseconds}ms");
        _output.WriteLine($"Generated {code.Length} characters");
    }

    [Fact]
    public async Task Benchmark_FullGeneration_OneTable()
    {
        // Arrange
        var table = CreateTestTable("Customer");
        var schema = SchemaBuilder.WithTable(table).Build();
        var stopwatch = new Stopwatch();

        // Act
        stopwatch.Start();
        
        await _repositoryInterfaceGenerator.GenerateAsync(table);
        await _repositoryGenerator.GenerateAsync(table);
        await _dbContextGenerator.GenerateAsync(schema);
        await _entityConfigurationGenerator.GenerateAsync(table);
        
        stopwatch.Stop();

        // Assert
        stopwatch.ElapsedMilliseconds.Should().BeLessThan(500,
            "Full generation for one table should complete in under 500ms");

        _output.WriteLine($"Full Generation (1 table): {stopwatch.ElapsedMilliseconds}ms");
    }

    [Fact]
    public async Task Benchmark_LargeSchema_10Tables()
    {
        // Arrange
        var builder = new DatabaseSchemaBuilder();
        
        for (int i = 1; i <= 10; i++)
        {
            var table = new TableBuilder().WithName($"Table{i}")
                .WithColumn("ID", "INT", isPrimaryKey: true, isIdentity: true)
                .WithColumn($"Name{i}", "NVARCHAR", maxLength: 100, isNullable: false)
                .WithColumn($"Value{i}", "INT", isNullable: false)
                .WithColumn($"agg_Count{i}", "INT", isNullable: false)
                .WithIndex($"IX_Table{i}_Name{i}", isUnique: false, columns: new[] { $"Name{i}" })
                .Build();
            
            builder.WithTable(table);
        }
        
        var schema = builder.Build();
        var stopwatch = new Stopwatch();

        // Act
        stopwatch.Start();
        
        // Generate DbContext once
        await _dbContextGenerator.GenerateAsync(schema);
        
        // Generate Repository + Configuration for each table
        foreach (var table in schema.Tables)
        {
            await _repositoryInterfaceGenerator.GenerateAsync(table);
            await _repositoryGenerator.GenerateAsync(table);
            await _entityConfigurationGenerator.GenerateAsync(table);
        }
        
        stopwatch.Stop();

        // Assert
        stopwatch.ElapsedMilliseconds.Should().BeLessThan(3000,
            "Generation for 10 tables should complete in under 3 seconds");

        _output.WriteLine($"Full Generation (10 tables): {stopwatch.ElapsedMilliseconds}ms");
        _output.WriteLine($"Average per table: {stopwatch.ElapsedMilliseconds / 10}ms");
    }

    [Fact]
    public async Task Benchmark_ComplexTable_ManyColumns()
    {
        // Arrange - Table with 20 columns
        var builder = new TableBuilder().WithName("ComplexTable")
            .WithColumn("ID", "INT", isPrimaryKey: true, isIdentity: true);
        
        for (int i = 1; i <= 20; i++)
        {
            builder.WithColumn($"Column{i}", "NVARCHAR", maxLength: 100);
        }
        
        var table = builder.Build();
        var stopwatch = new Stopwatch();

        // Act
        stopwatch.Start();
        
        await _repositoryInterfaceGenerator.GenerateAsync(table);
        await _repositoryGenerator.GenerateAsync(table);
        await _entityConfigurationGenerator.GenerateAsync(table);
        
        stopwatch.Stop();

        // Assert
        stopwatch.ElapsedMilliseconds.Should().BeLessThan(500,
            "Complex table with 20 columns should complete in under 500ms");

        _output.WriteLine($"Complex Table (20 columns): {stopwatch.ElapsedMilliseconds}ms");
    }

    [Fact]
    public async Task Benchmark_TableWithManyIndexes()
    {
        // Arrange - Table with 5 indexes
        var table = new TableBuilder().WithName("IndexedTable")
            .WithColumn("ID", "INT", isPrimaryKey: true, isIdentity: true)
            .WithColumn("Column1", "NVARCHAR", maxLength: 100)
            .WithColumn("Column2", "NVARCHAR", maxLength: 100)
            .WithColumn("Column3", "NVARCHAR", maxLength: 100)
            .WithColumn("Column4", "NVARCHAR", maxLength: 100)
            .WithColumn("Column5", "NVARCHAR", maxLength: 100)
            .WithIndex("IX_1", isUnique: true, columns: new[] { "Column1" })
            .WithIndex("IX_2", isUnique: false, columns: new[] { "Column2" })
            .WithIndex("IX_3", isUnique: false, columns: new[] { "Column3" })
            .WithIndex("IX_4", isUnique: false, columns: new[] { "Column4" })
            .WithIndex("IX_5", isUnique: false, columns: new[] { "Column5" })
            .Build();
        
        var stopwatch = new Stopwatch();

        // Act
        stopwatch.Start();
        
        await _repositoryInterfaceGenerator.GenerateAsync(table);
        await _repositoryGenerator.GenerateAsync(table);
        await _entityConfigurationGenerator.GenerateAsync(table);
        
        stopwatch.Stop();

        // Assert
        stopwatch.ElapsedMilliseconds.Should().BeLessThan(400,
            "Table with 5 indexes should complete in under 400ms");

        _output.WriteLine($"Table with 5 indexes: {stopwatch.ElapsedMilliseconds}ms");
    }

    [Fact]
    public async Task MemoryUsage_GenerateMultipleTables_DoesNotLeak()
    {
        // Arrange
        var initialMemory = GC.GetTotalMemory(forceFullCollection: true);
        
        // Act - Generate for 50 tables
        for (int i = 0; i < 50; i++)
        {
            var table = new TableBuilder().WithName($"Table{i}")
                .WithColumn("ID", "INT", isPrimaryKey: true, isIdentity: true)
                .WithColumn($"Name{i}", "NVARCHAR", maxLength: 100)
                .Build();
            
            await _repositoryInterfaceGenerator.GenerateAsync(table);
            await _repositoryGenerator.GenerateAsync(table);
            await _entityConfigurationGenerator.GenerateAsync(table);
        }
        
        // Force garbage collection
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();
        
        var finalMemory = GC.GetTotalMemory(forceFullCollection: false);
        var memoryGrowth = finalMemory - initialMemory;

        // Assert - Memory growth should be reasonable (< 50MB)
        memoryGrowth.Should().BeLessThan(50 * 1024 * 1024,
            "Memory growth should be less than 50MB after 50 table generations");

        _output.WriteLine($"Initial Memory: {initialMemory / 1024 / 1024}MB");
        _output.WriteLine($"Final Memory: {finalMemory / 1024 / 1024}MB");
        _output.WriteLine($"Growth: {memoryGrowth / 1024 / 1024}MB");
    }

    [Fact]
    public async Task Throughput_TablesPerSecond()
    {
        // Arrange
        var tables = new List<Table>();
        for (int i = 0; i < 20; i++)
        {
            tables.Add(new TableBuilder().WithName($"Table{i}")
                .WithColumn("ID", "INT", isPrimaryKey: true, isIdentity: true)
                .WithColumn("Name", "NVARCHAR", maxLength: 100)
                .Build());
        }
        
        var stopwatch = new Stopwatch();

        // Act
        stopwatch.Start();
        
        foreach (var table in tables)
        {
            await _repositoryInterfaceGenerator.GenerateAsync(table);
            await _repositoryGenerator.GenerateAsync(table);
            await _entityConfigurationGenerator.GenerateAsync(table);
        }
        
        stopwatch.Stop();

        // Calculate throughput
        var tablesPerSecond = (20.0 / stopwatch.ElapsedMilliseconds) * 1000;

        // Assert
        tablesPerSecond.Should().BeGreaterThan(5,
            "Should process at least 5 tables per second");

        _output.WriteLine($"Processed 20 tables in {stopwatch.ElapsedMilliseconds}ms");
        _output.WriteLine($"Throughput: {tablesPerSecond:F2} tables/second");
    }
}
