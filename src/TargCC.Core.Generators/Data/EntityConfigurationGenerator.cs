namespace TargCC.Core.Generators.Data;

using System.Globalization;
using System.Text;
using Microsoft.Extensions.Logging;
using TargCC.Core.Generators.Common;
using TargCC.Core.Interfaces.Models;

/// <summary>
/// Generates Entity Framework Core entity configuration classes.
/// </summary>
/// <remarks>
/// <para>
/// This generator creates IEntityTypeConfiguration classes that configure entity properties,
/// relationships, and constraints using the Fluent API. This provides clean separation of
/// entity mapping logic from the DbContext.
/// </para>
/// <para>
/// <strong>Generated Configuration Structure:</strong>
/// </para>
/// <list type="bullet">
/// <item><description>Table mapping configuration</description></item>
/// <item><description>Primary key configuration</description></item>
/// <item><description>Property configurations (required, max length, etc.)</description></item>
/// <item><description>Relationship configurations (HasMany, WithOne, etc.)</description></item>
/// <item><description>Index configurations</description></item>
/// <item><description>Comprehensive XML documentation</description></item>
/// </list>
/// </remarks>
public class EntityConfigurationGenerator : IEntityConfigurationGenerator
{
    // LoggerMessage delegates for high performance logging
    private static readonly Action<ILogger, string, Exception?> LogGeneratingConfiguration =
        LoggerMessage.Define<string>(
            LogLevel.Information,
            new EventId(1, nameof(GenerateAsync)),
            "Generating entity configuration for {TableName}");

    private static readonly Action<ILogger, string, Exception?> LogConfigurationGenerated =
        LoggerMessage.Define<string>(
            LogLevel.Information,
            new EventId(2, nameof(GenerateAsync)),
            "Successfully generated configuration for {TableName}");

    private readonly ILogger<EntityConfigurationGenerator> _logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="EntityConfigurationGenerator"/> class.
    /// </summary>
    /// <param name="logger">Logger for tracking generation process.</param>
    public EntityConfigurationGenerator(ILogger<EntityConfigurationGenerator> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc/>
    public async Task<string> GenerateAsync(Table table)
    {
        ArgumentNullException.ThrowIfNull(table);

        if (table.PrimaryKey == null)
        {
            throw new InvalidOperationException($"Table '{table.Name}' must have a primary key.");
        }

        LogGeneratingConfiguration(_logger, table.Name, null);

        var sb = new StringBuilder();

        // Add file header
        GenerateFileHeader(sb, table);

        // Add using statements
        GenerateUsings(sb);

        // Start namespace
        sb.AppendLine("namespace TargCC.Infrastructure.Data.Configurations;");
        sb.AppendLine();

        // Add class documentation
        GenerateClassDocumentation(sb, table);

        // Start class
        sb.AppendLine(CultureInfo.InvariantCulture, $"public class {table.Name}Configuration : IEntityTypeConfiguration<{table.Name}>");
        sb.AppendLine("{");

        // Generate Configure method
        GenerateConfigureMethod(sb, table);

        // Close class
        sb.AppendLine("}");

        LogConfigurationGenerated(_logger, table.Name, null);

        return await Task.FromResult(sb.ToString());
    }

    /// <summary>
    /// Generates the file header with auto-generation warning.
    /// </summary>
    private static void GenerateFileHeader(StringBuilder sb, Table table)
    {
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("//     This code was generated by TargCC");
        sb.AppendLine(CultureInfo.InvariantCulture, $"//     Generated for table: {table.Name}");
        sb.AppendLine(CultureInfo.InvariantCulture, $"//     Generation date: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        sb.AppendLine("//");
        sb.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
        sb.AppendLine("//     the code is regenerated.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates using statements.
    /// </summary>
    private static void GenerateUsings(StringBuilder sb)
    {
        sb.AppendLine("using Microsoft.EntityFrameworkCore;");
        sb.AppendLine("using Microsoft.EntityFrameworkCore.Metadata.Builders;");
        sb.AppendLine("using TargCC.Domain.Entities;");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates class-level XML documentation.
    /// </summary>
    private static void GenerateClassDocumentation(StringBuilder sb, Table table)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"/// Entity configuration for {table.Name} entity.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine("/// Configures the entity mapping, properties, relationships, and constraints");
        sb.AppendLine(CultureInfo.InvariantCulture, $"/// for the {table.Name} table using Entity Framework Core Fluent API.");
        sb.AppendLine("/// </remarks>");
    }

    /// <summary>
    /// Generates the Configure method with all entity configuration.
    /// </summary>
    private static void GenerateConfigureMethod(StringBuilder sb, Table table)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Configures the {table.Name} entity.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"builder\">The builder used to configure the entity.</param>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    public void Configure(EntityTypeBuilder<{table.Name}> builder)");
        sb.AppendLine("    {");
        sb.AppendLine("        ArgumentNullException.ThrowIfNull(builder);");
        sb.AppendLine();

        // Table mapping
        GenerateTableMapping(sb, table);

        // Primary key
        GeneratePrimaryKeyConfiguration(sb, table);

        // Properties
        GeneratePropertyConfigurations(sb, table);

        // Indexes
        GenerateIndexConfigurations(sb, table);

        // Relationships
        GenerateRelationshipConfigurations(sb, table);

        sb.AppendLine("    }");
    }

    /// <summary>
    /// Generates table mapping configuration.
    /// </summary>
    private static void GenerateTableMapping(StringBuilder sb, Table table)
    {
        sb.AppendLine("        // Table mapping");
        sb.AppendLine(CultureInfo.InvariantCulture, $"        builder.ToTable(\"{table.Name}\");");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates primary key configuration.
    /// </summary>
    private static void GeneratePrimaryKeyConfiguration(StringBuilder sb, Table table)
    {
        sb.AppendLine("        // Primary key");

        if (table.PrimaryKeyColumns.Count == 1)
        {
            // Single column primary key
            var pkColumn = table.PrimaryKeyColumns[0];
            sb.AppendLine(CultureInfo.InvariantCulture, $"        builder.HasKey(e => e.{pkColumn});");
        }
        else if (table.PrimaryKeyColumns.Count > 1)
        {
            // Composite primary key
            var columns = string.Join(", ", table.PrimaryKeyColumns.Select(c => $"e.{c}"));
            sb.AppendLine(CultureInfo.InvariantCulture, $"        builder.HasKey(e => new {{ {columns} }});");
        }

        sb.AppendLine();
    }

    /// <summary>
    /// Generates property configurations.
    /// </summary>
    private static void GeneratePropertyConfigurations(StringBuilder sb, Table table)
    {
        sb.AppendLine("        // Properties");

        foreach (var column in table.Columns.OrderBy(c => c.Name))
        {
            GeneratePropertyConfiguration(sb, column);
        }

        sb.AppendLine();
    }

    /// <summary>
    /// Generates configuration for a single property.
    /// </summary>
    private static void GeneratePropertyConfiguration(StringBuilder sb, Column column)
    {
        var propertyName = GetPropertyNameForColumn(column);
        var hasConfiguration = false;

        // Start property configuration
        sb.Append(CultureInfo.InvariantCulture, $"        builder.Property(e => e.{propertyName})");

        // ValueGeneratedOnAdd (for identity columns)
        if (column.IsIdentity)
        {
            sb.AppendLine();
            sb.Append("            .ValueGeneratedOnAdd()");
            hasConfiguration = true;
        }

        // IsRequired
        if (!column.IsNullable && !column.IsPrimaryKey)
        {
            sb.AppendLine();
            sb.Append("            .IsRequired()");
            hasConfiguration = true;
        }

        // HasMaxLength (for string columns)
        if (column.MaxLength.HasValue && column.MaxLength.Value > 0)
        {
            sb.AppendLine();
            sb.Append(CultureInfo.InvariantCulture, $"            .HasMaxLength({column.MaxLength.Value})");
            hasConfiguration = true;
        }

        // HasPrecision (for decimal/numeric columns)
        if (NeedsPrecisionConfiguration(column))
        {
            sb.AppendLine();
            var scale = column.ScaleNumeric ?? 0;
            sb.Append(CultureInfo.InvariantCulture, $"            .HasPrecision({column.PrecisionNumeric!.Value}, {scale})");
            hasConfiguration = true;
        }

        // HasDefaultValue (for columns with defaults)
        if (!string.IsNullOrEmpty(column.DefaultValue))
        {
            sb.AppendLine();
            var defaultValue = GetDefaultValueExpression(column);
            sb.Append(defaultValue);
            hasConfiguration = true;
        }

        // HasColumnName (if original name had prefix)
        if (column.Name != propertyName)
        {
            sb.AppendLine();
            sb.Append(CultureInfo.InvariantCulture, $"            .HasColumnName(\"{column.Name}\")");
            hasConfiguration = true;
        }

        // Close configuration
        sb.AppendLine(";");

        // Add blank line for readability
        if (hasConfiguration)
        {
            sb.AppendLine();
        }
    }

    /// <summary>
    /// Gets the C# property name for a database column, handling prefixes correctly.
    /// </summary>
    private static string GetPropertyNameForColumn(Column column)
    {
        var name = column.Name;

        // Handle TargCC prefixes
        if (name.StartsWith("eno_", StringComparison.OrdinalIgnoreCase))
        {
            // Hashed column: eno_Password -> PasswordHashed
            return CodeGenerationHelpers.SanitizeColumnName(name.Substring(4)) + "Hashed";
        }

        if (name.StartsWith("ent_", StringComparison.OrdinalIgnoreCase))
        {
            // Encrypted column: ent_CreditCard -> CreditCard
            return CodeGenerationHelpers.SanitizeColumnName(name.Substring(4));
        }

        if (name.StartsWith("lkp_", StringComparison.OrdinalIgnoreCase))
        {
            // Lookup column: lkp_Status -> StatusCode
            return CodeGenerationHelpers.SanitizeColumnName(name.Substring(4)) + "Code";
        }

        if (name.StartsWith("clc_", StringComparison.OrdinalIgnoreCase) ||
            name.StartsWith("agg_", StringComparison.OrdinalIgnoreCase))
        {
            // Calculated/Aggregate: clc_Total -> Total, agg_OrderCount -> OrderCount
            return CodeGenerationHelpers.SanitizeColumnName(name.Substring(4));
        }

        // No prefix - use as is
        return CodeGenerationHelpers.SanitizeColumnName(name);
    }

    /// <summary>
    /// Determines if a column needs precision configuration.
    /// </summary>
    private static bool NeedsPrecisionConfiguration(Column column)
    {
        var upperType = column.DataType.ToUpperInvariant();
        return (upperType == "DECIMAL" || upperType == "NUMERIC") && column.PrecisionNumeric.HasValue;
    }

    /// <summary>
    /// Gets the appropriate default value expression for a column.
    /// </summary>
    private static string GetDefaultValueExpression(Column column)
    {
        var upperType = column.DataType.ToUpperInvariant();
        var defaultValue = column.DefaultValue!;

        // Bit (boolean) columns with 0/1 defaults
        if (upperType == "BIT" && (defaultValue == "0" || defaultValue == "1"))
        {
            var boolValue = defaultValue == "1" ? "true" : "false";
            return $"            .HasDefaultValue({boolValue})";
        }

        // All other defaults use SQL expressions
        return $"            .HasDefaultValueSql(\"{defaultValue}\")";
    }

    /// <summary>
    /// Generates index configurations.
    /// </summary>
    private static void GenerateIndexConfigurations(StringBuilder sb, Table table)
    {
        if (table.Indexes == null || table.Indexes.Count == 0)
        {
            return;
        }

        sb.AppendLine("        // Indexes");

        foreach (var index in table.Indexes.Where(i => !i.IsPrimaryKey).OrderBy(i => i.Name))
        {
            GenerateIndexConfiguration(sb, index);
        }

        sb.AppendLine();
    }

    /// <summary>
    /// Generates configuration for a single index.
    /// </summary>
    private static void GenerateIndexConfiguration(StringBuilder sb, Index index)
    {
        if (index.ColumnNames.Count == 1)
        {
            // Single column index
            var columnName = CodeGenerationHelpers.SanitizeColumnName(index.ColumnNames[0]);
            sb.Append(CultureInfo.InvariantCulture, $"        builder.HasIndex(e => e.{columnName})");
        }
        else
        {
            // Composite index
            var columns = string.Join(", ", index.ColumnNames.Select(c =>
                $"e.{CodeGenerationHelpers.SanitizeColumnName(c)}"));
            sb.Append(CultureInfo.InvariantCulture, $"        builder.HasIndex(e => new {{ {columns} }})");
        }

        // Add index name
        sb.AppendLine();
        sb.Append(CultureInfo.InvariantCulture, $"            .HasDatabaseName(\"{index.Name}\")");

        // IsUnique
        if (index.IsUnique)
        {
            sb.AppendLine();
            sb.Append("            .IsUnique()");
        }

        sb.AppendLine(";");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates relationship configurations.
    /// </summary>
    private static void GenerateRelationshipConfigurations(StringBuilder sb, Table table)
    {
        if (table.Relationships == null || table.Relationships.Count == 0)
        {
            return;
        }

        sb.AppendLine("        // Relationships");

        // Group relationships by referenced table for cleaner organization
        var relationshipsByTable = table.Relationships
            .GroupBy(r => r.ReferencedTable)
            .OrderBy(g => g.Key);

        foreach (var group in relationshipsByTable)
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"        // {group.Key} relationships");

            foreach (var relationship in group)
            {
                GenerateRelationshipConfiguration(sb, relationship, table);
            }

            sb.AppendLine();
        }
    }

    /// <summary>
    /// Generates configuration for a single relationship.
    /// </summary>
    private static void GenerateRelationshipConfiguration(StringBuilder sb, Relationship relationship, Table table)
    {
        // Determine relationship type and generate appropriate configuration
        if (relationship.ChildTable == table.FullName)
        {
            // This table has the foreign key (Many-to-One)
            GenerateManyToOneRelationship(sb, relationship);
        }
        else if (relationship.ParentTable == table.FullName)
        {
            // This table is referenced (One-to-Many)
            GenerateOneToManyRelationship(sb, relationship);
        }
    }

    /// <summary>
    /// Generates Many-to-One relationship configuration (this table has FK).
    /// </summary>
    private static void GenerateManyToOneRelationship(StringBuilder sb, Relationship relationship)
    {
        var navigationProperty = relationship.ParentTable;
        var foreignKeyProperty = CodeGenerationHelpers.SanitizeColumnName(relationship.ChildColumn);

        sb.AppendLine(CultureInfo.InvariantCulture, $"        builder.HasOne(e => e.{navigationProperty})");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            .WithMany(r => r.{CodeGenerationHelpers.MakePlural(relationship.ChildTable)})");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            .HasForeignKey(e => e.{foreignKeyProperty})");

        if (!string.IsNullOrEmpty(relationship.Name))
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"            .HasConstraintName(\"{relationship.Name}\")");
        }

        sb.AppendLine("            .OnDelete(DeleteBehavior.Restrict);");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates One-to-Many relationship configuration (other table has FK).
    /// </summary>
    private static void GenerateOneToManyRelationship(StringBuilder sb, Relationship relationship)
    {
        var navigationProperty = CodeGenerationHelpers.MakePlural(relationship.ChildTable);
        var foreignKeyProperty = CodeGenerationHelpers.SanitizeColumnName(relationship.ChildColumn);
        var deleteBehavior = GetDeleteBehavior(relationship.DeleteAction);

        sb.AppendLine(CultureInfo.InvariantCulture, $"        builder.HasMany(e => e.{navigationProperty})");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            .WithOne(o => o.{relationship.ParentTable})");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            .HasForeignKey(o => o.{foreignKeyProperty})");

        if (!string.IsNullOrEmpty(relationship.Name))
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"            .HasConstraintName(\"{relationship.Name}\")");
        }

        sb.AppendLine(CultureInfo.InvariantCulture, $"            .OnDelete(DeleteBehavior.{deleteBehavior});");
        sb.AppendLine();
    }

    /// <summary>
    /// Gets the appropriate EF Core DeleteBehavior for a given delete action.
    /// </summary>
    private static string GetDeleteBehavior(string? deleteAction)
    {
        if (string.IsNullOrEmpty(deleteAction))
        {
            return "Restrict";
        }

        return deleteAction.ToUpperInvariant() switch
        {
            "CASCADE" => "Cascade",
            "SET NULL" => "SetNull",
            "NO ACTION" => "NoAction",
            _ => "Restrict"
        };
    }
}
