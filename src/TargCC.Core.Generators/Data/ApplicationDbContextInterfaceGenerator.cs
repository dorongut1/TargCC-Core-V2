using System.Globalization;
using System.Text;
using Microsoft.Extensions.Logging;
using TargCC.Core.Generators.API;
using TargCC.Core.Generators.Common;
using TargCC.Core.Interfaces.Models;

namespace TargCC.Core.Generators.Data;

/// <summary>
/// Generates IApplicationDbContext interface for the Application layer.
/// </summary>
public class ApplicationDbContextInterfaceGenerator : IApplicationDbContextInterfaceGenerator
{
    // LoggerMessage delegates for high performance logging
    private static readonly Action<ILogger, int, Exception?> LogGeneratingInterface =
        LoggerMessage.Define<int>(
            LogLevel.Information,
            new EventId(1, nameof(GenerateAsync)),
            "Generating IApplicationDbContext interface with {TableCount} tables");

    private static readonly Action<ILogger, Exception?> LogInterfaceGenerated =
        LoggerMessage.Define(
            LogLevel.Information,
            new EventId(2, nameof(GenerateAsync)),
            "Successfully generated IApplicationDbContext interface");

    private readonly ILogger<ApplicationDbContextInterfaceGenerator> _logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="ApplicationDbContextInterfaceGenerator"/> class.
    /// </summary>
    /// <param name="logger">Logger instance.</param>
    public ApplicationDbContextInterfaceGenerator(ILogger<ApplicationDbContextInterfaceGenerator> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc/>
    public async Task<string> GenerateAsync(DatabaseSchema schema, string rootNamespace)
    {
        ArgumentNullException.ThrowIfNull(schema);
        ArgumentException.ThrowIfNullOrEmpty(rootNamespace);

        if (schema.Tables == null || schema.Tables.Count == 0)
        {
            throw new InvalidOperationException("Schema must contain at least one table.");
        }

        LogGeneratingInterface(_logger, schema.Tables.Count, null);

        var sb = new StringBuilder();

        // Add file header
        GenerateFileHeader(sb, schema);

        // Add using statements
        GenerateUsings(sb, rootNamespace);

        // Start namespace
        sb.AppendLine(CultureInfo.InvariantCulture, $"namespace {rootNamespace}.Application.Common.Interfaces;");
        sb.AppendLine();

        // Add interface documentation
        GenerateInterfaceDocumentation(sb, schema);

        // Start interface
        sb.AppendLine("public interface IApplicationDbContext");
        sb.AppendLine("{");

        // Generate DbSet properties
        GenerateDbSetProperties(sb, schema);

        // Generate SaveChangesAsync method
        GenerateSaveChangesAsync(sb);

        // Close interface
        sb.AppendLine("}");

        LogInterfaceGenerated(_logger, null);

        return await Task.FromResult(sb.ToString());
    }

    private static void GenerateFileHeader(StringBuilder sb, DatabaseSchema schema)
    {
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("//     This code was generated by TargCC");
        sb.AppendLine(CultureInfo.InvariantCulture, $"//     Generated from database: {schema.DatabaseName}");
        sb.AppendLine(CultureInfo.InvariantCulture, $"//     Generation date: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        sb.AppendLine("//");
        sb.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
        sb.AppendLine("//     the code is regenerated.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
    }

    private static void GenerateUsings(StringBuilder sb, string rootNamespace)
    {
        sb.AppendLine("using Microsoft.EntityFrameworkCore;");
        sb.AppendLine(CultureInfo.InvariantCulture, $"using {rootNamespace}.Domain.Entities;");
        sb.AppendLine();
    }

    private static void GenerateInterfaceDocumentation(StringBuilder sb, DatabaseSchema schema)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"/// Database context interface for {schema.DatabaseName} database.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine("/// This interface defines the contract for the application's database context,");
        sb.AppendLine("/// providing access to all entities through DbSet properties.");
        sb.AppendLine("/// </remarks>");
    }

    private static void GenerateDbSetProperties(StringBuilder sb, DatabaseSchema schema)
    {
        foreach (var table in schema.Tables.OrderBy(t => t.Name))
        {
            var entityName = BaseApiGenerator.GetClassName(table.Name);
            var dbSetName = CodeGenerationHelpers.MakePlural(entityName);

            sb.AppendLine("    /// <summary>");
            sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Gets or sets the DbSet for {entityName} entities.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine(CultureInfo.InvariantCulture, $"    DbSet<{entityName}> {dbSetName} {{ get; set; }}");
            sb.AppendLine();
        }
    }

    private static void GenerateSaveChangesAsync(StringBuilder sb)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Saves all changes made in this context to the database.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"cancellationToken\">A token to cancel the asynchronous operation.</param>");
        sb.AppendLine("    /// <returns>The number of state entries written to the database.</returns>");
        sb.AppendLine("    Task<int> SaveChangesAsync(CancellationToken cancellationToken = default);");
    }
}
