// ------------------------------------------------------------------------------
// <auto-generated>
//     This file is part of TargCC.Core.Generators
//     Copyright (c) 2024-2025 TargCC. All rights reserved.
// </auto-generated>
// ------------------------------------------------------------------------------

#nullable enable

using System.Diagnostics;
using Microsoft.Extensions.Logging;
using TargCC.Core.Generators.Project.Models;

namespace TargCC.Core.Generators.Project;

/// <summary>
/// Generates complete project structure including solution, projects, and folders.
/// </summary>
public class ProjectStructureGenerator : IProjectStructureGenerator
{
    private readonly ILogger<ProjectStructureGenerator> _logger;
    private readonly ISolutionGenerator _solutionGenerator;
    private readonly IProjectFileGenerator _projectFileGenerator;

    /// <summary>
    /// Initializes a new instance of the <see cref="ProjectStructureGenerator"/> class.
    /// </summary>
    /// <param name="logger">Logger instance.</param>
    /// <param name="solutionGenerator">Solution generator.</param>
    /// <param name="projectFileGenerator">Project file generator.</param>
    public ProjectStructureGenerator(
        ILogger<ProjectStructureGenerator> logger,
        ISolutionGenerator solutionGenerator,
        IProjectFileGenerator projectFileGenerator)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _solutionGenerator = solutionGenerator ?? throw new ArgumentNullException(nameof(solutionGenerator));
        _projectFileGenerator = projectFileGenerator ?? throw new ArgumentNullException(nameof(projectFileGenerator));
    }

    /// <inheritdoc/>
    public async Task<SolutionGenerationResult> GenerateStructureAsync(ProjectGenerationOptions options)
    {
        ArgumentNullException.ThrowIfNull(options);

        var sw = Stopwatch.StartNew();
        var result = new SolutionGenerationResult();

        try
        {
            _logger.LogInformation("Generating project structure for: {ProjectName}", options.ProjectName);

            // Create folder structure
            var directories = await CreateFolderStructureAsync(options);
            _logger.LogInformation("Created {Count} directories", directories.Count);

            // Get projects for this architecture
            var projects = GetProjectsForArchitecture(options);

            // Create solution info
            var solutionInfo = CreateSolutionInfo(options, projects);

            // Generate solution file
            var slnPath = await _solutionGenerator.GenerateAndSaveAsync(solutionInfo);
            result.GeneratedFiles.Add(slnPath);

            // Generate project files
            foreach (var project in projects)
            {
                var csprojPath = await _projectFileGenerator.GenerateAndSaveAsync(
                    project, options, options.OutputDirectory);
                result.GeneratedFiles.Add(csprojPath);

                // Create standard folders within each project
                await CreateProjectFoldersAsync(project, options);
            }

            result.SolutionInfo = solutionInfo;
            result.Success = true;
            sw.Stop();
            result.Duration = sw.Elapsed;

            _logger.LogInformation(
                "Project structure generated successfully: {FileCount} files in {Duration}ms",
                result.GeneratedFiles.Count,
                sw.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating project structure");
            result.Success = false;
            result.ErrorMessage = ex.Message;
        }

        return result;
    }

    /// <inheritdoc/>
    public async Task<List<string>> CreateFolderStructureAsync(ProjectGenerationOptions options)
    {
        ArgumentNullException.ThrowIfNull(options);

        var directories = new List<string>();
        var baseDir = options.OutputDirectory;

        // Root directory
        Directory.CreateDirectory(baseDir);
        directories.Add(baseDir);

        // src folder
        var srcDir = Path.Combine(baseDir, "src");
        Directory.CreateDirectory(srcDir);
        directories.Add(srcDir);

        // tests folder
        if (options.IncludeTests)
        {
            var testsDir = Path.Combine(baseDir, "tests");
            Directory.CreateDirectory(testsDir);
            directories.Add(testsDir);
        }

        await Task.CompletedTask; // For async signature
        return directories;
    }

    /// <inheritdoc/>
    public List<ProjectInfo> GetProjectsForArchitecture(ProjectGenerationOptions options)
    {
        ArgumentNullException.ThrowIfNull(options);

        var projects = new List<ProjectInfo>();

        switch (options.Architecture)
        {
            case ArchitectureType.CleanArchitecture:
                projects.Add(_projectFileGenerator.CreateProjectInfo(options.ProjectName, ProjectType.Domain, options));
                projects.Add(_projectFileGenerator.CreateProjectInfo(options.ProjectName, ProjectType.Application, options));
                projects.Add(_projectFileGenerator.CreateProjectInfo(options.ProjectName, ProjectType.Infrastructure, options));
                projects.Add(_projectFileGenerator.CreateProjectInfo(options.ProjectName, ProjectType.Api, options));
                if (options.IncludeTests)
                {
                    projects.Add(_projectFileGenerator.CreateProjectInfo(options.ProjectName, ProjectType.Tests, options));
                }
                break;

            case ArchitectureType.MinimalApi:
                // Simplified structure for minimal APIs
                projects.Add(_projectFileGenerator.CreateProjectInfo(options.ProjectName, ProjectType.Api, options));
                if (options.IncludeTests)
                {
                    projects.Add(_projectFileGenerator.CreateProjectInfo(options.ProjectName, ProjectType.Tests, options));
                }
                break;

            case ArchitectureType.ThreeTier:
                // Traditional 3-tier
                projects.Add(_projectFileGenerator.CreateProjectInfo(options.ProjectName, ProjectType.Domain, options));
                projects.Add(_projectFileGenerator.CreateProjectInfo(options.ProjectName, ProjectType.Infrastructure, options));
                projects.Add(_projectFileGenerator.CreateProjectInfo(options.ProjectName, ProjectType.Api, options));
                if (options.IncludeTests)
                {
                    projects.Add(_projectFileGenerator.CreateProjectInfo(options.ProjectName, ProjectType.Tests, options));
                }
                break;
        }

        return projects;
    }

    private SolutionInfo CreateSolutionInfo(ProjectGenerationOptions options, List<ProjectInfo> projects)
    {
        var solutionInfo = new SolutionInfo
        {
            Name = options.ProjectName,
            OutputDirectory = options.OutputDirectory
        };

        // Create solution folders
        var srcFolder = new SolutionFolder { Name = "src" };
        var testsFolder = new SolutionFolder { Name = "tests" };

        foreach (var project in projects)
        {
            solutionInfo.Projects.Add(project);

            if (project.Type == ProjectType.Tests)
            {
                testsFolder.ProjectGuids.Add(project.ProjectGuid);
            }
            else
            {
                srcFolder.ProjectGuids.Add(project.ProjectGuid);
            }
        }

        solutionInfo.Folders.Add(srcFolder);
        if (options.IncludeTests && testsFolder.ProjectGuids.Any())
        {
            solutionInfo.Folders.Add(testsFolder);
        }

        return solutionInfo;
    }

    private async Task CreateProjectFoldersAsync(ProjectInfo project, ProjectGenerationOptions options)
    {
        var projectDir = Path.Combine(options.OutputDirectory, project.RelativePath);
        Directory.CreateDirectory(projectDir);

        // Create standard folders based on project type
        var folders = GetStandardFoldersForProjectType(project.Type);
        foreach (var folder in folders)
        {
            var folderPath = Path.Combine(projectDir, folder);
            Directory.CreateDirectory(folderPath);
        }

        await Task.CompletedTask;
    }

    private static List<string> GetStandardFoldersForProjectType(ProjectType projectType)
    {
        return projectType switch
        {
            ProjectType.Domain => new List<string>
            {
                "Entities",
                "ValueObjects",
                "Enums",
                "Events",
                "Exceptions",
                "Interfaces"
            },
            ProjectType.Application => new List<string>
            {
                "Commands",
                "Queries",
                "DTOs",
                "Interfaces",
                "Mappings",
                "Behaviors",
                "Validators"
            },
            ProjectType.Infrastructure => new List<string>
            {
                "Data",
                "Data/Configurations",
                "Repositories",
                "Services",
                "Migrations"
            },
            ProjectType.Api => new List<string>
            {
                "Controllers",
                "Middleware",
                "Filters",
                "Extensions"
            },
            ProjectType.Tests => new List<string>
            {
                "Unit",
                "Integration",
                "Fixtures"
            },
            _ => new List<string>()
        };
    }
}
