// ------------------------------------------------------------------------------
// <auto-generated>
//     This file is part of TargCC.Core.Generators
//     Copyright (c) 2024-2025 TargCC. All rights reserved.
// </auto-generated>
// ------------------------------------------------------------------------------

#nullable enable

using System.Text;
using Microsoft.Extensions.Logging;
using TargCC.Core.Generators.Project.Models;

namespace TargCC.Core.Generators.Project;

/// <summary>
/// Generates project files (.csproj).
/// </summary>
public class ProjectFileGenerator : IProjectFileGenerator
{
    private readonly ILogger<ProjectFileGenerator> _logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="ProjectFileGenerator"/> class.
    /// </summary>
    /// <param name="logger">Logger instance.</param>
    public ProjectFileGenerator(ILogger<ProjectFileGenerator> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc/>
    public string Generate(ProjectInfo projectInfo, ProjectGenerationOptions options)
    {
        ArgumentNullException.ThrowIfNull(projectInfo);
        ArgumentNullException.ThrowIfNull(options);

        _logger.LogInformation("Generating project file: {ProjectName}", projectInfo.Name);

        var sb = new StringBuilder();
        sb.AppendLine("<Project Sdk=\"Microsoft.NET.Sdk\">");
        sb.AppendLine();

        // PropertyGroup
        sb.AppendLine("  <PropertyGroup>");
        sb.AppendLine($"    <TargetFramework>{options.TargetFramework}</TargetFramework>");

        if (projectInfo.OutputType != "Library")
        {
            sb.AppendLine($"    <OutputType>{projectInfo.OutputType}</OutputType>");
        }

        if (options.EnableNullable)
        {
            sb.AppendLine("    <Nullable>enable</Nullable>");
        }

        if (options.ImplicitUsings)
        {
            sb.AppendLine("    <ImplicitUsings>enable</ImplicitUsings>");
        }

        sb.AppendLine($"    <LangVersion>{options.LangVersion}</LangVersion>");

        if (!string.IsNullOrEmpty(projectInfo.RootNamespace))
        {
            sb.AppendLine($"    <RootNamespace>{projectInfo.RootNamespace}</RootNamespace>");
        }

        // Add XML documentation for non-test projects
        if (projectInfo.Type != ProjectType.Tests)
        {
            sb.AppendLine("    <GenerateDocumentationFile>true</GenerateDocumentationFile>");
            sb.AppendLine("    <NoWarn>$(NoWarn);1591</NoWarn>");
        }

        sb.AppendLine("  </PropertyGroup>");

        // Package References
        if (projectInfo.PackageReferences.Any())
        {
            sb.AppendLine();
            sb.AppendLine("  <ItemGroup>");
            foreach (var package in projectInfo.PackageReferences)
            {
                if (!string.IsNullOrEmpty(package.PrivateAssets))
                {
                    sb.AppendLine($"    <PackageReference Include=\"{package.Name}\" Version=\"{package.Version}\">");
                    sb.AppendLine($"      <PrivateAssets>{package.PrivateAssets}</PrivateAssets>");
                    sb.AppendLine("    </PackageReference>");
                }
                else
                {
                    sb.AppendLine($"    <PackageReference Include=\"{package.Name}\" Version=\"{package.Version}\" />");
                }
            }
            sb.AppendLine("  </ItemGroup>");
        }

        // Project References
        if (projectInfo.ProjectReferences.Any())
        {
            sb.AppendLine();
            sb.AppendLine("  <ItemGroup>");
            foreach (var reference in projectInfo.ProjectReferences)
            {
                sb.AppendLine($"    <ProjectReference Include=\"{reference}\" />");
            }
            sb.AppendLine("  </ItemGroup>");
        }

        sb.AppendLine();
        sb.AppendLine("</Project>");

        _logger.LogInformation("Project file generated: {ProjectName}", projectInfo.Name);

        return sb.ToString();
    }

    /// <inheritdoc/>
    public async Task<string> GenerateAndSaveAsync(
        ProjectInfo projectInfo,
        ProjectGenerationOptions options,
        string outputDirectory)
    {
        ArgumentNullException.ThrowIfNull(projectInfo);
        ArgumentNullException.ThrowIfNull(options);
        ArgumentException.ThrowIfNullOrEmpty(outputDirectory);

        var content = Generate(projectInfo, options);
        var filePath = Path.Combine(outputDirectory, projectInfo.CsprojPath);

        // Ensure directory exists
        var directory = Path.GetDirectoryName(filePath);
        if (!string.IsNullOrEmpty(directory))
        {
            Directory.CreateDirectory(directory);
        }

        await File.WriteAllTextAsync(filePath, content);
        _logger.LogInformation("Project file saved to: {FilePath}", filePath);

        return filePath;
    }

    /// <inheritdoc/>
    public ProjectInfo CreateProjectInfo(
        string projectName,
        ProjectType projectType,
        ProjectGenerationOptions options)
    {
        ArgumentException.ThrowIfNullOrEmpty(projectName);
        ArgumentNullException.ThrowIfNull(options);

        var fullName = GetProjectFullName(projectName, projectType);
        var relativePath = GetProjectRelativePath(projectName, projectType, options);

        var projectInfo = new ProjectInfo
        {
            Name = fullName,
            Type = projectType,
            RelativePath = relativePath,
            TargetFramework = options.TargetFramework,
            RootNamespace = options.EffectiveNamespace + GetNamespaceSuffix(projectType),
            OutputType = projectType == ProjectType.Api ? "Exe" : "Library"
        };

        // Add packages based on project type
        projectInfo.PackageReferences = GetPackagesForProjectType(projectType);

        // Add project references based on project type
        projectInfo.ProjectReferences = GetProjectReferencesForType(projectName, projectType, options);

        return projectInfo;
    }

    private static string GetProjectFullName(string projectName, ProjectType projectType)
    {
        return projectType switch
        {
            ProjectType.Domain => $"{projectName}.Domain",
            ProjectType.Application => $"{projectName}.Application",
            ProjectType.Infrastructure => $"{projectName}.Infrastructure",
            ProjectType.Api => $"{projectName}.API",
            ProjectType.Tests => $"{projectName}.Tests",
            _ => projectName
        };
    }

    private static string GetProjectRelativePath(string projectName, ProjectType projectType, ProjectGenerationOptions options)
    {
        var fullName = GetProjectFullName(projectName, projectType);
        return projectType == ProjectType.Tests
            ? Path.Combine("tests", fullName)
            : Path.Combine("src", fullName);
    }

    private static string GetNamespaceSuffix(ProjectType projectType)
    {
        return projectType switch
        {
            ProjectType.Domain => ".Domain",
            ProjectType.Application => ".Application",
            ProjectType.Infrastructure => ".Infrastructure",
            ProjectType.Api => ".API",
            ProjectType.Tests => ".Tests",
            _ => string.Empty
        };
    }

    private static List<PackageReference> GetPackagesForProjectType(ProjectType projectType)
    {
        return projectType switch
        {
            ProjectType.Domain => new List<PackageReference>
            {
                // Domain layer has minimal dependencies
            },
            ProjectType.Application => new List<PackageReference>
            {
                new() { Name = "MediatR", Version = "12.2.0" },
                new() { Name = "FluentValidation", Version = "11.9.0" },
                new() { Name = "FluentValidation.DependencyInjectionExtensions", Version = "11.9.0" },
                new() { Name = "AutoMapper", Version = "12.0.1" },
                new() { Name = "Microsoft.Extensions.Logging.Abstractions", Version = "8.0.10" },
                new() { Name = "Microsoft.EntityFrameworkCore", Version = "8.0.10" }
            },
            ProjectType.Infrastructure => new List<PackageReference>
            {
                new() { Name = "Microsoft.EntityFrameworkCore", Version = "8.0.10" },
                new() { Name = "Microsoft.EntityFrameworkCore.SqlServer", Version = "8.0.10" },
                new() { Name = "Dapper", Version = "2.1.35" },
                new() { Name = "Microsoft.Data.SqlClient", Version = "5.2.2" },
                new() { Name = "Microsoft.Data.Sqlite", Version = "8.0.10" }
            },
            ProjectType.Api => new List<PackageReference>
            {
                new() { Name = "Swashbuckle.AspNetCore", Version = "6.5.0" },
                new() { Name = "AutoMapper", Version = "12.0.1" },
                new() { Name = "AutoMapper.Extensions.Microsoft.DependencyInjection", Version = "12.0.1" },
                new() { Name = "Microsoft.EntityFrameworkCore.SqlServer", Version = "8.0.10" },
                new() { Name = "Microsoft.AspNetCore.OpenApi", Version = "8.0.10" },
                new() { Name = "Hangfire.AspNetCore", Version = "1.8.9" },
                new() { Name = "Hangfire.SqlServer", Version = "1.8.9" }
            },
            ProjectType.Tests => new List<PackageReference>
            {
                new() { Name = "Microsoft.NET.Test.Sdk", Version = "17.9.0" },
                new() { Name = "xunit", Version = "2.7.0" },
                new() { Name = "xunit.runner.visualstudio", Version = "2.5.7", PrivateAssets = "all" },
                new() { Name = "Moq", Version = "4.20.70" },
                new() { Name = "FluentAssertions", Version = "6.12.0" },
                new() { Name = "coverlet.collector", Version = "6.0.1", PrivateAssets = "all" }
            },
            _ => new List<PackageReference>()
        };
    }

    private static List<string> GetProjectReferencesForType(
        string projectName,
        ProjectType projectType,
        ProjectGenerationOptions options)
    {
        var references = new List<string>();

        switch (projectType)
        {
            case ProjectType.Application:
                // Application references Domain
                references.Add($"..\\{projectName}.Domain\\{projectName}.Domain.csproj");
                break;

            case ProjectType.Infrastructure:
                // Infrastructure references Domain and Application
                references.Add($"..\\{projectName}.Domain\\{projectName}.Domain.csproj");
                references.Add($"..\\{projectName}.Application\\{projectName}.Application.csproj");
                break;

            case ProjectType.Api:
                // API references all layers
                references.Add($"..\\{projectName}.Domain\\{projectName}.Domain.csproj");
                references.Add($"..\\{projectName}.Application\\{projectName}.Application.csproj");
                references.Add($"..\\{projectName}.Infrastructure\\{projectName}.Infrastructure.csproj");
                break;

            case ProjectType.Tests:
                // Tests reference all source projects
                references.Add($"..\\..\\src\\{projectName}.Domain\\{projectName}.Domain.csproj");
                references.Add($"..\\..\\src\\{projectName}.Application\\{projectName}.Application.csproj");
                references.Add($"..\\..\\src\\{projectName}.Infrastructure\\{projectName}.Infrastructure.csproj");
                references.Add($"..\\..\\src\\{projectName}.API\\{projectName}.API.csproj");
                break;
        }

        return references;
    }
}
