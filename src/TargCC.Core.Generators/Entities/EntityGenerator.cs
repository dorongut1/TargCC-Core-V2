// <copyright file="EntityGenerator.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

namespace TargCC.Core.Generators.Entities
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
    using Microsoft.Extensions.Logging;
    using TargCC.Core.Interfaces.Models;

    /// <summary>
    /// Main entity generator that orchestrates entity class creation.
    /// </summary>
    public partial class EntityGenerator : IEntityGenerator
    {
        private readonly ILogger<EntityGenerator> _logger;

        /// <summary>
        /// Initializes a new instance of the <see cref="EntityGenerator"/> class.
        /// </summary>
        /// <param name="logger">Logger instance.</param>
        public EntityGenerator(ILogger<EntityGenerator> logger)
        {
            ArgumentNullException.ThrowIfNull(logger);
            _logger = logger;
        }

        /// <inheritdoc/>
        public async Task<string> GenerateAsync(Table table, DatabaseSchema schema, string @namespace = "YourNamespace.Entities")
        {
            ArgumentNullException.ThrowIfNull(table);
            ArgumentNullException.ThrowIfNull(schema);
            ArgumentException.ThrowIfNullOrWhiteSpace(@namespace);

            LogGeneratingEntity(_logger, table.Name);

            return await Task.Run(() => GenerateEntityClass(table, schema, @namespace)).ConfigureAwait(false);
        }

        /// <inheritdoc/>
        public async Task<Dictionary<string, string>> GenerateAllAsync(DatabaseSchema schema, string @namespace = "YourNamespace.Entities")
        {
            ArgumentNullException.ThrowIfNull(schema);
            ArgumentException.ThrowIfNullOrWhiteSpace(@namespace);

            LogGeneratingAllEntities(_logger, schema.Tables.Count);

            var result = new Dictionary<string, string>();

            foreach (var table in schema.Tables)
            {
                var className = GetClassName(table.Name);
                var code = await GenerateAsync(table, schema, @namespace).ConfigureAwait(false);
                result[className] = code;
            }

            LogCompletedAllEntities(_logger, result.Count);

            return result;
        }

        private static void AppendFileHeader(StringBuilder sb)
        {
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("//     This code was generated by TargCC.Core.Generators.");
            sb.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
            sb.AppendLine("//     the code is regenerated.");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine();
        }

        private static void AppendUsings(StringBuilder sb)
        {
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.ComponentModel.DataAnnotations;");
            sb.AppendLine("using System.ComponentModel.DataAnnotations.Schema;");
            sb.AppendLine("using System.Text.Json.Serialization;");
            sb.AppendLine();
        }

        private static void AppendClassDocumentation(StringBuilder sb, Table table)
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Entity class for {table.Name} table.");
            sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Generated: {DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss", CultureInfo.InvariantCulture)}");
            sb.AppendLine("    /// </summary>");
        }

        private static string GenerateBackingFields(Table table)
        {
            var sb = new StringBuilder();

            foreach (var column in table.Columns)
            {
                var backingField = PropertyGenerator.GenerateBackingField(column);
                if (!string.IsNullOrEmpty(backingField))
                {
                    sb.AppendLine(CultureInfo.InvariantCulture, $"        {backingField}");
                }
            }

            return sb.ToString();
        }

        private static string GeneratePrimaryKeyProperties(Table table)
        {
            var sb = new StringBuilder();
            var pkColumns = table.Columns.Where(c => c.IsPrimaryKey).ToList();

            if (pkColumns.Count > 0)
            {
                sb.AppendLine("        // Primary Key(s)");
                foreach (var pk in pkColumns)
                {
                    sb.Append(PropertyGenerator.GenerateProperty(pk));
                }

                sb.AppendLine();
            }

            return sb.ToString();
        }

        private static string GenerateRegularProperties(Table table)
        {
            var sb = new StringBuilder();
            var regularColumns = table.Columns.Where(c =>
                !c.IsPrimaryKey &&
                !PropertyGenerator.IsAuditColumn(c) &&
                c.Prefix != ColumnPrefix.FakeUniqueIndex).ToList();

            if (regularColumns.Count > 0)
            {
                sb.AppendLine("        // Regular Properties");
                foreach (var column in regularColumns)
                {
                    sb.Append(PropertyGenerator.GenerateProperty(column));
                }

                sb.AppendLine();
            }

            return sb.ToString();
        }

        private static string GenerateAuditProperties(Table table)
        {
            var sb = new StringBuilder();
            var auditColumns = table.Columns.Where(c => PropertyGenerator.IsAuditColumn(c)).ToList();

            if (auditColumns.Count > 0)
            {
                sb.AppendLine("        // Audit Properties");
                foreach (var column in auditColumns)
                {
                    sb.Append(PropertyGenerator.GenerateProperty(column));
                }

                sb.AppendLine();
            }

            return sb.ToString();
        }

        private static string GetClassName(string tableName)
        {
            // Use the same PascalCase conversion as API generators for consistency
            return TargCC.Core.Generators.API.BaseApiGenerator.GetClassName(tableName);
        }

        // LoggerMessage delegates
        [LoggerMessage(
            EventId = 200,
            Level = LogLevel.Debug,
            Message = "Generating entity for table: {TableName}")]
        private static partial void LogGeneratingEntity(ILogger logger, string tableName);

        [LoggerMessage(
            EventId = 201,
            Level = LogLevel.Information,
            Message = "Generating entities for {Count} tables")]
        private static partial void LogGeneratingAllEntities(ILogger logger, int count);

        [LoggerMessage(
            EventId = 202,
            Level = LogLevel.Debug,
            Message = "Successfully generated entity: {ClassName}")]
        private static partial void LogCompletedEntity(ILogger logger, string className);

        [LoggerMessage(
            EventId = 203,
            Level = LogLevel.Information,
            Message = "Successfully generated {Count} entities")]
        private static partial void LogCompletedAllEntities(ILogger logger, int count);

        private string GenerateEntityClass(Table table, DatabaseSchema schema, string @namespace)
        {
            var sb = new StringBuilder();
            var className = GetClassName(table.Name);

            // File header
            AppendFileHeader(sb);

            // Usings
            AppendUsings(sb);

            // Namespace
            sb.AppendLine(CultureInfo.InvariantCulture, $"namespace {@namespace}");
            sb.AppendLine("{");

            // Class documentation
            AppendClassDocumentation(sb, table);

            // Class attributes
            sb.AppendLine(CultureInfo.InvariantCulture, $"    [Table(\"{table.Name}\")]");
            sb.AppendLine(CultureInfo.InvariantCulture, $"    public partial class {className}");
            sb.AppendLine("    {");

            // Backing fields
            var backingFields = GenerateBackingFields(table);
            if (!string.IsNullOrEmpty(backingFields))
            {
                sb.AppendLine("        #region Backing Fields");
                sb.AppendLine();
                sb.Append(backingFields);
                sb.AppendLine("        #endregion");
                sb.AppendLine();
            }

            // Properties
            sb.AppendLine("        #region Properties");
            sb.AppendLine();

            // Primary keys first
            var pkProperties = GeneratePrimaryKeyProperties(table);
            if (!string.IsNullOrEmpty(pkProperties))
            {
                sb.Append(pkProperties);
            }

            // Regular properties
            var regularProperties = GenerateRegularProperties(table);
            if (!string.IsNullOrEmpty(regularProperties))
            {
                sb.Append(regularProperties);
            }

            // Audit properties
            var auditProperties = GenerateAuditProperties(table);
            if (!string.IsNullOrEmpty(auditProperties))
            {
                sb.Append(auditProperties);
            }

            sb.AppendLine("        #endregion");
            sb.AppendLine();

            // Relationships
            var relationships = RelationshipGenerator.GenerateNavigationProperties(table, schema);
            if (!string.IsNullOrEmpty(relationships))
            {
                sb.AppendLine("        #region Relationships");
                sb.AppendLine();
                sb.Append(relationships);
                sb.AppendLine("        #endregion");
                sb.AppendLine();
            }

            // Constructor
            sb.AppendLine("        #region Constructors");
            sb.AppendLine();
            sb.Append(MethodGenerator.GenerateConstructor(table, className, schema));
            sb.AppendLine();
            sb.AppendLine("        #endregion");
            sb.AppendLine();

            // Methods
            sb.AppendLine("        #region Methods");
            sb.AppendLine();
            sb.Append(MethodGenerator.GenerateToString(table, className));
            sb.AppendLine();
            sb.Append(MethodGenerator.GenerateClone(table, className));
            sb.AppendLine();
            sb.Append(MethodGenerator.GenerateEquals(table, className));
            sb.AppendLine();
            sb.Append(MethodGenerator.GenerateGetHashCode(table));
            sb.AppendLine();
            sb.AppendLine("        #endregion");

            // Helper methods
            var helperMethods = MethodGenerator.GenerateHelperMethods(table);
            if (!string.IsNullOrEmpty(helperMethods))
            {
                sb.AppendLine();
                sb.AppendLine("        #region Helper Methods");
                sb.AppendLine();
                sb.Append(helperMethods);
                sb.AppendLine();
                sb.AppendLine("        #endregion");
            }

            // Close class
            sb.AppendLine("    }");

            // Close namespace
            sb.AppendLine("}");

            LogCompletedEntity(_logger, className);

            return sb.ToString();
        }
    }
}
