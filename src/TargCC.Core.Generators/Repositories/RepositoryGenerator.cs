namespace TargCC.Core.Generators.Repositories;

using System.Globalization;
using System.Text;
using Microsoft.Extensions.Logging;
using TargCC.Core.Generators.Common;
using TargCC.Core.Generators.Entities;
using TargCC.Core.Interfaces.Models;

/// <summary>
/// Generates repository implementation code from database table metadata using Dapper and Stored Procedures.
/// </summary>
/// <remarks>
/// <para>
/// This generator creates concrete repository classes that implement the repository interfaces.
/// The generated code uses Dapper for efficient data access via stored procedures, includes
/// proper error handling, logging, and follows best practices for async/await patterns.
/// </para>
/// <para>
/// <strong>Generated Class Structure:</strong>
/// </para>
/// <code>
/// public class CustomerRepository : ICustomerRepository
/// {
///     private readonly IDbConnection _connection;
///     private readonly ILogger&lt;CustomerRepository&gt; _logger;
///
///     public CustomerRepository(IDbConnection connection, ILogger&lt;CustomerRepository&gt; logger)
///     {
///         _connection = connection ?? throw new ArgumentNullException(nameof(connection));
///         _logger = logger ?? throw new ArgumentNullException(nameof(logger));
///     }
///
///     // CRUD implementations...
/// }
/// </code>
/// </remarks>
public class RepositoryGenerator : IRepositoryGenerator
{
    // LoggerMessage delegates for high performance logging
    private static readonly Action<ILogger, string, Exception?> LogGeneratingRepository =
        LoggerMessage.Define<string>(
            LogLevel.Information,
            new EventId(1, nameof(GenerateAsync)),
            "Generating repository implementation for table: {TableName}");

    private static readonly Action<ILogger, string, Exception?> LogRepositoryGenerated =
        LoggerMessage.Define<string>(
            LogLevel.Information,
            new EventId(2, nameof(GenerateAsync)),
            "Successfully generated repository implementation for table: {TableName}");

    private readonly ILogger<RepositoryGenerator> _logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="RepositoryGenerator"/> class.
    /// </summary>
    /// <param name="logger">Logger for tracking generation process.</param>
    public RepositoryGenerator(ILogger<RepositoryGenerator> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <inheritdoc/>
    public async Task<string> GenerateAsync(Table table, string rootNamespace = "YourApp")
    {
        return await GenerateAsync(table, null, rootNamespace);
    }

    /// <inheritdoc/>
    public async Task<string> GenerateAsync(Table table, DatabaseSchema? schema, string rootNamespace = "YourApp")
    {
        ArgumentNullException.ThrowIfNull(table);

        // Ensure table has a primary key (infers identifier for VIEWs)
        EnsurePrimaryKey(table);

        LogGeneratingRepository(_logger, table.Name, null);

        var sb = new StringBuilder();

        // Add file header
        GenerateFileHeader(sb, table);

        // Add using statements
        GenerateUsings(sb, rootNamespace);

        // Start class
        StartClass(sb, table);

        // Generate fields
        GenerateFields(sb, table);

        // Generate constructor
        GenerateConstructor(sb, table);

        // Generate CRUD methods
        GenerateGetByIdAsync(sb, table, rootNamespace);
        GenerateGetAllAsync(sb, table, rootNamespace);
        GenerateGetFilteredAsync(sb, table, rootNamespace);

        // Only generate Add/Update/Delete for tables, not for views (views are read-only)
        if (!table.IsView)
        {
            GenerateAddAsync(sb, table, rootNamespace);
            GenerateUpdateAsync(sb, table, rootNamespace);
            GenerateDeleteAsync(sb, table, rootNamespace);
        }

        // Generate index-based query methods
        GenerateIndexBasedMethods(sb, table, rootNamespace);

        // Only generate aggregate updates for tables, not for views (views are read-only)
        if (!table.IsView)
        {
            GenerateUpdateAggregatesAsync(sb, table, rootNamespace);
        }

        // Generate related data methods (Master-Detail Views)
        if (schema != null)
        {
            GenerateRelatedDataMethods(sb, table, schema, rootNamespace);
        }

        // Generate helper methods
        GenerateExistsAsync(sb, table, rootNamespace);

        // Close class
        CloseClass(sb);

        LogRepositoryGenerated(_logger, table.Name, null);

        return await Task.FromResult(sb.ToString());
    }

    /// <summary>
    /// Generates the file header with XML documentation.
    /// </summary>
    private static void GenerateFileHeader(StringBuilder sb, Table table)
    {
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"//     This code was generated by TargCC.Core.Generators v2.0");
        sb.AppendLine(CultureInfo.InvariantCulture, $"//     Generated from table: {table.FullName}");
        sb.AppendLine(CultureInfo.InvariantCulture, $"//     Generation date: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        sb.AppendLine("//");
        sb.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
        sb.AppendLine("//     the code is regenerated.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates using statements.
    /// </summary>
    private static void GenerateUsings(StringBuilder sb, string rootNamespace)
    {
        sb.AppendLine(CultureInfo.InvariantCulture, $"namespace {rootNamespace}.Infrastructure.Repositories;");
        sb.AppendLine();
        sb.AppendLine("using System.Data;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Dapper;");
        sb.AppendLine("using Microsoft.Extensions.Logging;");
        sb.AppendLine(CultureInfo.InvariantCulture, $"using {rootNamespace}.Domain.Entities;");
        sb.AppendLine(CultureInfo.InvariantCulture, $"using {rootNamespace}.Domain.Interfaces;");
        sb.AppendLine();
    }

    /// <summary>
    /// Starts the class declaration with XML documentation.
    /// </summary>
    private static void StartClass(StringBuilder sb, Table table)
    {
        string entityName = GetClassName(table.Name);
        string className = $"{entityName}Repository";
        string interfaceName = $"I{entityName}Repository";

        sb.AppendLine("/// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"/// Repository implementation for {entityName} entity data access operations.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine("/// <para>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"/// This repository provides data access for the {entityName} entity using Dapper");
        sb.AppendLine("/// for stored procedure calls. All operations are async and support cancellation.");
        sb.AppendLine("/// </para>");
        sb.AppendLine("/// </remarks>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"public class {className} : {interfaceName}");
        sb.AppendLine("{");
    }

    /// <summary>
    /// Generates private fields.
    /// </summary>
    private static void GenerateFields(StringBuilder sb, Table table)
    {
        string entityName = GetClassName(table.Name);

        sb.AppendLine("    private readonly IDbConnection _connection;");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    private readonly ILogger<{entityName}Repository> _logger;");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates constructor.
    /// </summary>
    private static void GenerateConstructor(StringBuilder sb, Table table)
    {
        string entityName = GetClassName(table.Name);
        string className = $"{entityName}Repository";

        sb.AppendLine("    /// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Initializes a new instance of the <see cref=\"{className}\"/> class.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"connection\">Database connection for Dapper operations.</param>");
        sb.AppendLine("    /// <param name=\"logger\">Logger for tracking repository operations.</param>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    public {className}(IDbConnection connection, ILogger<{className}> logger)");
        sb.AppendLine("    {");
        sb.AppendLine("        _connection = connection ?? throw new ArgumentNullException(nameof(connection));");
        sb.AppendLine("        _logger = logger ?? throw new ArgumentNullException(nameof(logger));");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates GetByIdAsync method.
    /// </summary>
    private static void GenerateGetByIdAsync(StringBuilder sb, Table table, string rootNamespace)
    {
        string entityName = GetClassName(table.Name);
        string qualifiedEntityName = GetQualifiedEntityName(entityName, rootNamespace);
        var pkColumn = table.Columns.Find(c => c.IsPrimaryKey);

        if (pkColumn == null)
        {
            return;
        }

        string pkType = CodeGenerationHelpers.GetCSharpType(pkColumn.DataType);
        string spName = $"SP_Get{entityName}ByID";

        sb.AppendLine("    /// <inheritdoc/>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    public async System.Threading.Tasks.Task<{qualifiedEntityName}?> GetByIdAsync({pkType} id, CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        sb.AppendLine(CultureInfo.InvariantCulture, $"        _logger.LogDebug(\"Getting {entityName} by ID: {{Id}}\", id);");
        sb.AppendLine();
        sb.AppendLine("        try");
        sb.AppendLine("        {");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            var result = await _connection.QueryFirstOrDefaultAsync<{qualifiedEntityName}>(");
        sb.AppendLine(CultureInfo.InvariantCulture, $"                \"{spName}\",");
        sb.AppendLine("                new { ID = id },");
        sb.AppendLine("                commandType: CommandType.StoredProcedure);");
        sb.AppendLine();
        sb.AppendLine(CultureInfo.InvariantCulture, $"            _logger.LogDebug(\"{entityName} found: {{Found}}\", result != null);");
        sb.AppendLine("            return result;");
        sb.AppendLine("        }");
        sb.AppendLine("        catch (Exception ex)");
        sb.AppendLine("        {");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            _logger.LogError(ex, \"Error getting {entityName} by ID: {{Id}}\", id);");
        sb.AppendLine("            throw;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates GetAllAsync method.
    /// </summary>
    private static void GenerateGetAllAsync(StringBuilder sb, Table table, string rootNamespace)
    {
        string entityName = GetClassName(table.Name);
        string qualifiedEntityName = GetQualifiedEntityName(entityName, rootNamespace);
        string spName = $"SP_GetAll{entityName}s";

        sb.AppendLine("    /// <inheritdoc/>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    public async System.Threading.Tasks.Task<IEnumerable<{qualifiedEntityName}>> GetAllAsync(int? skip = null, int? take = null, CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        sb.AppendLine(CultureInfo.InvariantCulture,  $"        _logger.LogDebug(\"Getting all {entityName} entities. Skip: {{Skip}}, Take: {{Take}}\", skip, take);");
        sb.AppendLine();
        sb.AppendLine("        try");
        sb.AppendLine("        {");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            var result = await _connection.QueryAsync<{qualifiedEntityName}>(");
        sb.AppendLine(CultureInfo.InvariantCulture, $"                \"{spName}\",");
        sb.AppendLine("                new { Skip = skip, Take = take },");
        sb.AppendLine("                commandType: CommandType.StoredProcedure);");
        sb.AppendLine();
        sb.AppendLine(CultureInfo.InvariantCulture, $"            _logger.LogDebug(\"Retrieved {{Count}} {entityName} entities\", result.Count());");
        sb.AppendLine("            return result;");
        sb.AppendLine("        }");
        sb.AppendLine("        catch (Exception ex)");
        sb.AppendLine("        {");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            _logger.LogError(ex, \"Error getting all {entityName} entities\");");
        sb.AppendLine("            throw;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates GetFilteredAsync method based on table indexes.
    /// </summary>
    private static void GenerateGetFilteredAsync(StringBuilder sb, Table table, string rootNamespace)
    {
        var filterableIndexes = table.Indexes?
            .Where(i => !i.IsPrimaryKey && i.ColumnNames != null && i.ColumnNames.Count > 0)
            .ToList();

        if (filterableIndexes == null || filterableIndexes.Count == 0)
        {
            // No filterable indexes, skip
            return;
        }

        string entityName = GetClassName(table.Name);
        string qualifiedEntityName = GetQualifiedEntityName(entityName, rootNamespace);
        string spName = $"SP_GetFiltered{entityName}s";
        var parameters = new List<(string paramName, string paramType, string columnName)>();

        // Collect unique indexed columns
        var processedColumns = new HashSet<string>();
        foreach (var index in filterableIndexes)
        {
            foreach (var columnName in index.ColumnNames)
            {
                if (processedColumns.Contains(columnName))
                {
                    continue;
                }

                processedColumns.Add(columnName);
                var column = table.Columns.Find(c => c.Name == columnName);
                if (column != null)
                {
                    string paramName = CodeGenerationHelpers.ToCamelCase(CodeGenerationHelpers.SanitizeColumnName(columnName));
                    string paramType = CodeGenerationHelpers.GetCSharpType(column.DataType) + "?"; // Nullable
                    parameters.Add((paramName, paramType, columnName));
                }
            }
        }

        if (parameters.Count == 0)
        {
            return;
        }

        // Method signature
        var paramList = string.Join(
            ", ",
            parameters.Select(p => $"{p.paramType} {p.paramName} = null")
            .Concat(["int? skip = null", "int? take = null", "CancellationToken cancellationToken = default"]));

        sb.AppendLine("    /// <inheritdoc/>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    public async System.Threading.Tasks.Task<IEnumerable<{qualifiedEntityName}>> GetFilteredAsync({paramList})");
        sb.AppendLine("    {");
        sb.AppendLine(CultureInfo.InvariantCulture, $"        _logger.LogDebug(\"Getting filtered {entityName} entities\");");
        sb.AppendLine();
        sb.AppendLine("        try");
        sb.AppendLine("        {");

        // Build dynamic object for parameters
        sb.AppendLine("            var parameters = new {");
        foreach (var (paramName, _, columnName) in parameters)
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"                {columnName} = {paramName},");
        }

        sb.AppendLine("                Skip = skip,");
        sb.AppendLine("                Take = take");
        sb.AppendLine("            };");
        sb.AppendLine();

        sb.AppendLine(CultureInfo.InvariantCulture, $"            var result = await _connection.QueryAsync<{qualifiedEntityName}>(");
        sb.AppendLine(CultureInfo.InvariantCulture, $"                \"{spName}\",");
        sb.AppendLine("                parameters,");
        sb.AppendLine("                commandType: CommandType.StoredProcedure);");
        sb.AppendLine();
        sb.AppendLine(CultureInfo.InvariantCulture, $"            _logger.LogDebug(\"Retrieved {{Count}} filtered {entityName} entities\", result.Count());");
        sb.AppendLine("            return result;");
        sb.AppendLine("        }");
        sb.AppendLine("        catch (Exception ex)");
        sb.AppendLine("        {");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            _logger.LogError(ex, \"Error getting filtered {entityName} entities\");");
        sb.AppendLine("            throw;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates AddAsync method.
    /// </summary>
    private static void GenerateAddAsync(StringBuilder sb, Table table, string rootNamespace)
    {
        string entityName = GetClassName(table.Name);
        string qualifiedEntityName = GetQualifiedEntityName(entityName, rootNamespace);
        string spName = $"SP_Add{entityName}";

        sb.AppendLine("    /// <inheritdoc/>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    public async System.Threading.Tasks.Task AddAsync({qualifiedEntityName} entity, CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (entity == null)");
        sb.AppendLine("        {");
        sb.AppendLine("            throw new ArgumentNullException(nameof(entity));");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine(CultureInfo.InvariantCulture, $"        _logger.LogDebug(\"Adding new {entityName}\");");
        sb.AppendLine();
        sb.AppendLine("        try");
        sb.AppendLine("        {");
        sb.AppendLine("            var parameters = new DynamicParameters();");

        // Add only insertable columns (exclude IDENTITY, audit columns that are auto-set)
        var insertableColumns = table.Columns
            .Where(c => !c.IsPrimaryKey &&
                       !IsAuditColumn(c.Name) &&
                       !c.Name.Equals("AddedOn", StringComparison.OrdinalIgnoreCase) &&
                       !c.Name.Equals("ChangedOn", StringComparison.OrdinalIgnoreCase) &&
                       !c.Name.Equals("ChangedBy", StringComparison.OrdinalIgnoreCase) &&
                       !c.Name.Equals("AddedBy", StringComparison.OrdinalIgnoreCase) &&
                       !c.Name.Equals("BLG_AddedBy", StringComparison.OrdinalIgnoreCase))
            .ToList();

        foreach (var column in insertableColumns)
        {
            var propertyName = PrefixHandler.GetPropertyName(column);
            sb.AppendLine(CultureInfo.InvariantCulture, $"            parameters.Add(\"@{column.Name}\", entity.{propertyName});");
        }

        // Add AddedBy if AddedBy or BLG_AddedBy exists
        var addedByColumn = table.Columns.Find(c =>
            c.Name.Equals("BLG_AddedBy", StringComparison.OrdinalIgnoreCase) ||
            c.Name.Equals("AddedBy", StringComparison.OrdinalIgnoreCase));
        if (addedByColumn != null)
        {
            sb.AppendLine("            parameters.Add(\"@AddedBy\", entity.AddedBy);");
        }

        sb.AppendLine();
        sb.AppendLine(CultureInfo.InvariantCulture, $"            await _connection.ExecuteAsync(");
        sb.AppendLine(CultureInfo.InvariantCulture, $"                \"{spName}\",");
        sb.AppendLine("                parameters,");
        sb.AppendLine("                commandType: CommandType.StoredProcedure);");
        sb.AppendLine();
        sb.AppendLine(CultureInfo.InvariantCulture, $"            _logger.LogInformation(\"{entityName} added successfully\");");
        sb.AppendLine("        }");
        sb.AppendLine("        catch (Exception ex)");
        sb.AppendLine("        {");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            _logger.LogError(ex, \"Error adding {entityName}\");");
        sb.AppendLine("            throw;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates UpdateAsync method.
    /// </summary>
    private static void GenerateUpdateAsync(StringBuilder sb, Table table, string rootNamespace)
    {
        string entityName = GetClassName(table.Name);
        string qualifiedEntityName = GetQualifiedEntityName(entityName, rootNamespace);
        string spName = $"SP_Update{entityName}";
        var pkColumn = table.Columns.Find(c => c.IsPrimaryKey);

        if (pkColumn == null)
        {
            return;
        }

        string pkPropertyName = PrefixHandler.GetPropertyName(pkColumn);

        sb.AppendLine("    /// <inheritdoc/>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    public async System.Threading.Tasks.Task UpdateAsync({qualifiedEntityName} entity, CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (entity == null)");
        sb.AppendLine("        {");
        sb.AppendLine("            throw new ArgumentNullException(nameof(entity));");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine(CultureInfo.InvariantCulture, $"        _logger.LogDebug(\"Updating {entityName} with ID: {{Id}}\", entity.{pkPropertyName});");
        sb.AppendLine();
        sb.AppendLine("        try");
        sb.AppendLine("        {");
        sb.AppendLine("            var parameters = new DynamicParameters();");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            parameters.Add(\"@{pkColumn.Name}\", entity.{pkPropertyName});");

        // Add only updateable columns (exclude audit columns and ChangedBy - which is added separately)
        var updateableColumns = table.Columns
            .Where(c => !c.IsPrimaryKey &&
                       !IsAuditColumn(c.Name) &&
                       !c.Name.Equals("AddedOn", StringComparison.OrdinalIgnoreCase) &&
                       !c.Name.Equals("AddedBy", StringComparison.OrdinalIgnoreCase) &&
                       !c.Name.Equals("ChangedOn", StringComparison.OrdinalIgnoreCase) &&
                       !c.Name.Equals("ChangedBy", StringComparison.OrdinalIgnoreCase) &&
                       !c.Name.Equals("BLG_ChangedBy", StringComparison.OrdinalIgnoreCase))
            .ToList();

        foreach (var column in updateableColumns)
        {
            var propertyName = PrefixHandler.GetPropertyName(column);
            sb.AppendLine(CultureInfo.InvariantCulture, $"            parameters.Add(\"@{column.Name}\", entity.{propertyName});");
        }

        // Add ChangedBy if BLG_ChangedBy or ChangedBy exists
        var changedByColumn = table.Columns.Find(c =>
            c.Name.Equals("BLG_ChangedBy", StringComparison.OrdinalIgnoreCase) ||
            c.Name.Equals("ChangedBy", StringComparison.OrdinalIgnoreCase));
        if (changedByColumn != null)
        {
            sb.AppendLine("            parameters.Add(\"@ChangedBy\", entity.ChangedBy);");
        }

        sb.AppendLine();
        sb.AppendLine(CultureInfo.InvariantCulture, $"            await _connection.ExecuteAsync(");
        sb.AppendLine(CultureInfo.InvariantCulture, $"                \"{spName}\",");
        sb.AppendLine("                parameters,");
        sb.AppendLine("                commandType: CommandType.StoredProcedure);");
        sb.AppendLine();
        sb.AppendLine(CultureInfo.InvariantCulture, $"            _logger.LogInformation(\"{entityName} updated successfully. ID: {{Id}}\", entity.{pkPropertyName});");
        sb.AppendLine("        }");
        sb.AppendLine("        catch (Exception ex)");
        sb.AppendLine("        {");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            _logger.LogError(ex, \"Error updating {entityName} with ID: {{Id}}\", entity.{pkPropertyName});");
        sb.AppendLine("            throw;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates DeleteAsync method.
    /// </summary>
    private static void GenerateDeleteAsync(StringBuilder sb, Table table, string rootNamespace)
    {
        _ = rootNamespace; // Not used - DeleteAsync doesn't reference entity types in parameters
        string entityName = GetClassName(table.Name);
        string spName = $"SP_Delete{entityName}";
        var pkColumn = table.Columns.Find(c => c.IsPrimaryKey);

        if (pkColumn == null)
        {
            return;
        }

        string pkType = CodeGenerationHelpers.GetCSharpType(pkColumn.DataType);

        sb.AppendLine("    /// <inheritdoc/>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    public async System.Threading.Tasks.Task DeleteAsync({pkType} id, CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        sb.AppendLine(CultureInfo.InvariantCulture, $"        _logger.LogDebug(\"Deleting {entityName} with ID: {{Id}}\", id);");
        sb.AppendLine();
        sb.AppendLine("        try");
        sb.AppendLine("        {");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            await _connection.ExecuteAsync(");
        sb.AppendLine(CultureInfo.InvariantCulture, $"                \"{spName}\",");
        sb.AppendLine("                new { ID = id },");
        sb.AppendLine("                commandType: CommandType.StoredProcedure);");
        sb.AppendLine();
        sb.AppendLine(CultureInfo.InvariantCulture, $"            _logger.LogInformation(\"{entityName} deleted successfully. ID: {{Id}}\", id);");
        sb.AppendLine("        }");
        sb.AppendLine("        catch (Exception ex)");
        sb.AppendLine("        {");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            _logger.LogError(ex, \"Error deleting {entityName} with ID: {{Id}}\", id);");
        sb.AppendLine("            throw;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates index-based query methods.
    /// </summary>
    private static void GenerateIndexBasedMethods(StringBuilder sb, Table table, string rootNamespace)
    {
        if (table.Indexes == null || table.Indexes.Count == 0)
        {
            return;
        }

        string entityName = GetClassName(table.Name);

        // Process each non-primary key index
        foreach (var index in table.Indexes.Where(i => !i.IsPrimaryKey))
        {
            if (index.ColumnNames == null || index.ColumnNames.Count == 0)
            {
                continue;
            }

            GenerateSingleIndexMethod(sb, table, index, entityName, rootNamespace);
        }
    }

    /// <summary>
    /// Generates a single index-based query method.
    /// </summary>
    private static void GenerateSingleIndexMethod(StringBuilder sb, Table table, Index index, string entityName, string rootNamespace)
    {
        // Build method name and SP name
        string methodName = CodeGenerationHelpers.BuildMethodName("GetBy", index.ColumnNames);
        string spName = $"SP_Get{entityName}By{string.Join("And", index.ColumnNames.Select(CodeGenerationHelpers.SanitizeColumnName))}";

        // Build parameters
        var (paramList, paramDictStr) = BuildIndexMethodParameters(table, index);

        // Generate method signature and body
        string qualifiedEntityName = GetQualifiedEntityName(entityName, rootNamespace);
        GenerateIndexMethodImplementation(sb, qualifiedEntityName, methodName, spName, index, paramList, paramDictStr);
    }

    /// <summary>
    /// Builds parameter list and dictionary string for an index method.
    /// </summary>
    private static (string paramList, string paramDictStr) BuildIndexMethodParameters(Table table, Index index)
    {
        var parameters = new List<string>();
        var paramDict = new List<string>();

        foreach (var columnName in index.ColumnNames)
        {
            var column = table.Columns.Find(c => c.Name == columnName);
            if (column != null)
            {
                string paramType = CodeGenerationHelpers.GetCSharpType(column.DataType);
                string paramName = CodeGenerationHelpers.ToCamelCase(
                    CodeGenerationHelpers.SanitizeColumnName(columnName));
                string columnNameSanitized = CodeGenerationHelpers.SanitizeColumnName(columnName);

                parameters.Add($"{paramType} {paramName}");

                // FIX: Change from dictionary syntax to property syntax
                paramDict.Add($"{columnNameSanitized} = {paramName}");
            }
        }

        return (string.Join(", ", parameters), string.Join(", ", paramDict));
    }

    /// <summary>
    /// Generates the method implementation (signature + body) for an index method.
    /// </summary>
    private static void GenerateIndexMethodImplementation(
     StringBuilder sb,
     string qualifiedEntityName,
     string methodName,
     string spName,
     Index index,
     string paramList,
     string paramDictStr)
    {
        // Extract simple entity name from qualified name for logging (e.g., "Task" from "App.Domain.Entities.Task")
        string entityNameForLogging = qualifiedEntityName.Contains('.', StringComparison.Ordinal)
            ? qualifiedEntityName[(qualifiedEntityName.LastIndexOf('.') + 1) ..]
            : qualifiedEntityName;

        sb.AppendLine("    /// <inheritdoc/>");

        // Method signature
        if (index.IsUnique)
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"    public async System.Threading.Tasks.Task<{qualifiedEntityName}?> {methodName}Async({paramList}, CancellationToken cancellationToken = default)");
        }
        else
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"    public async System.Threading.Tasks.Task<IEnumerable<{qualifiedEntityName}>> {methodName}Async({paramList}, CancellationToken cancellationToken = default)");
        }

        sb.AppendLine("    {");
        sb.AppendLine(CultureInfo.InvariantCulture, $"        _logger.LogDebug(\"Getting {entityNameForLogging} by {string.Join(", ", index.ColumnNames)}\");");
        sb.AppendLine();
        sb.AppendLine("        try");
        sb.AppendLine("        {");

        // Dapper call
        if (index.IsUnique)
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"            var result = await _connection.QueryFirstOrDefaultAsync<{qualifiedEntityName}>(");
        }
        else
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"            var result = await _connection.QueryAsync<{qualifiedEntityName}>(");
        }

        sb.AppendLine(CultureInfo.InvariantCulture, $"                \"{spName}\",");
        sb.AppendLine(CultureInfo.InvariantCulture, $"                new {{ {paramDictStr} }},");
        sb.AppendLine("                commandType: CommandType.StoredProcedure);");
        sb.AppendLine();

        // Logging
        if (index.IsUnique)
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"            _logger.LogDebug(\"{entityNameForLogging} found: {{Found}}\", result != null);");
        }
        else
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"            _logger.LogDebug(\"Retrieved {{Count}} {entityNameForLogging} entities\", result.Count());");
        }

        sb.AppendLine("            return result;");
        sb.AppendLine("        }");
        sb.AppendLine("        catch (Exception ex)");
        sb.AppendLine("        {");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            _logger.LogError(ex, \"Error getting {entityNameForLogging} by {string.Join(", ", index.ColumnNames)}\");");
        sb.AppendLine("            throw;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates UpdateAggregatesAsync method for tables with agg_ columns.
    /// </summary>
    private static void GenerateUpdateAggregatesAsync(StringBuilder sb, Table table, string rootNamespace)
    {
        _ = rootNamespace; // Not used - UpdateAggregatesAsync only uses primitive types in parameters

        // Find aggregate columns using LINQ
        var aggColumns = table.Columns
            .Where(c => c.Name.StartsWith("agg_", StringComparison.OrdinalIgnoreCase))
            .ToList();

        if (aggColumns.Count == 0)
        {
            return;
        }

        string entityName = GetClassName(table.Name);
        string spName = $"SP_Update{entityName}Aggregates";
        var pkColumn = table.Columns.Find(c => c.IsPrimaryKey);

        if (pkColumn == null)
        {
            return;
        }

        string pkType = CodeGenerationHelpers.GetCSharpType(pkColumn.DataType);

        // Build parameter list
        var parameters = new List<string> { $"{pkType} id" };
        var paramDict = new List<string> { "ID = id" };

        foreach (var column in aggColumns)
        {
            string paramType = CodeGenerationHelpers.GetCSharpType(column.DataType);
            string paramName = CodeGenerationHelpers.ToCamelCase(
                CodeGenerationHelpers.SanitizeColumnName(column.Name));
            string columnNameSanitized = CodeGenerationHelpers.SanitizeColumnName(column.Name);

            parameters.Add($"{paramType} {paramName}");

            // FIX: Change from dictionary syntax to property syntax
            paramDict.Add($"{columnNameSanitized} = {paramName}");
        }

        string paramList = string.Join(", ", parameters);
        string paramDictStr = string.Join(", ", paramDict);

        sb.AppendLine("    /// <inheritdoc/>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    public async System.Threading.Tasks.Task UpdateAggregatesAsync({paramList}, CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        sb.AppendLine(CultureInfo.InvariantCulture, $"        _logger.LogDebug(\"Updating {entityName} aggregates for ID: {{Id}}\", id);");
        sb.AppendLine();
        sb.AppendLine("        try");
        sb.AppendLine("        {");
        sb.AppendLine($"            await _connection.ExecuteAsync(");
        sb.AppendLine(CultureInfo.InvariantCulture, $"                \"{spName}\",");
        sb.AppendLine(CultureInfo.InvariantCulture, $"                new {{ {paramDictStr} }},");  // ✅ FIXED - now generates: new { ID = id, ... }
        sb.AppendLine("                commandType: CommandType.StoredProcedure);");
        sb.AppendLine();
        sb.AppendLine(CultureInfo.InvariantCulture, $"            _logger.LogInformation(\"{entityName} aggregates updated successfully. ID: {{Id}}\", id);");
        sb.AppendLine("        }");
        sb.AppendLine("        catch (Exception ex)");
        sb.AppendLine("        {");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            _logger.LogError(ex, \"Error updating {entityName} aggregates. ID: {{Id}}\", id);");
        sb.AppendLine("            throw;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates ExistsAsync method.
    /// </summary>
    private static void GenerateExistsAsync(StringBuilder sb, Table table, string rootNamespace)
    {
        string entityName = GetClassName(table.Name);
        string qualifiedEntityName = GetQualifiedEntityName(entityName, rootNamespace);
        var pkColumn = table.Columns.Find(c => c.IsPrimaryKey);

        if (pkColumn == null)
        {
            return;
        }

        string pkType = CodeGenerationHelpers.GetCSharpType(pkColumn.DataType);
        string spName = $"SP_Get{entityName}ByID";

        sb.AppendLine("    /// <inheritdoc/>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    public async Task<bool> ExistsAsync({pkType} id, CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        sb.AppendLine(CultureInfo.InvariantCulture, $"        _logger.LogDebug(\"Checking if {entityName} exists with ID: {{Id}}\", id);");
        sb.AppendLine();
        sb.AppendLine("        try");
        sb.AppendLine("        {");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            var result = await _connection.QueryFirstOrDefaultAsync<{qualifiedEntityName}>(");
        sb.AppendLine(CultureInfo.InvariantCulture, $"                \"{spName}\",");
        sb.AppendLine("                new { ID = id },");
        sb.AppendLine("                commandType: CommandType.StoredProcedure);");
        sb.AppendLine();
        sb.AppendLine("            bool exists = result != null;");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            _logger.LogDebug(\"{entityName} exists: {{Exists}}\", exists);");
        sb.AppendLine("            return exists;");
        sb.AppendLine("        }");
        sb.AppendLine("        catch (Exception ex)");
        sb.AppendLine("        {");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            _logger.LogError(ex, \"Error checking if {entityName} exists. ID: {{Id}}\", id);");
        sb.AppendLine("            throw;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
    }

    /// <summary>
    /// Determines if a column is an audit column (CLC_, BLG_, AGG_, SCB_).
    /// </summary>
    private static bool IsAuditColumn(string columnName)
    {
        return columnName.StartsWith("CLC_", StringComparison.OrdinalIgnoreCase) ||
               columnName.StartsWith("BLG_", StringComparison.OrdinalIgnoreCase) ||
               columnName.StartsWith("AGG_", StringComparison.OrdinalIgnoreCase) ||
               columnName.StartsWith("SCB_", StringComparison.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Generates related data methods (Master-Detail Views) based on FK relationships.
    /// </summary>
    private static void GenerateRelatedDataMethods(StringBuilder sb, Table table, DatabaseSchema schema, string rootNamespace)
    {
        if (schema.Relationships == null || schema.Relationships.Count == 0)
        {
            return;
        }

        // Find all relationships where this table is the parent
        var parentRelationships = schema.Relationships
            .Where(r => r.ParentTable == table.FullName && r.IsEnabled)
            .ToList();

        if (parentRelationships.Count == 0)
        {
            return;
        }

        string entityName = GetClassName(table.Name);
        var pkColumn = table.Columns.Find(c => c.IsPrimaryKey);

        if (pkColumn == null)
        {
            return;
        }

        string pkType = CodeGenerationHelpers.GetCSharpType(pkColumn.DataType);

        // Track generated methods to avoid duplicates when multiple FKs point to same child table
        var generatedMethods = new HashSet<string>();

        foreach (var relationship in parentRelationships)
        {
            // Find the child table
            var childTable = schema.Tables.Find(t => t.FullName == relationship.ChildTable);
            if (childTable == null)
            {
                continue;
            }

            // Generate method name to check for duplicates
            // IMPORTANT: Use childTable.Name directly (not GetClassName) to match interface generator
            string childrenName = Pluralize(childTable.Name);
            string methodName = $"Get{childrenName}Async";

            // Skip if we've already generated this method (happens with multiple FKs to same table)
            if (generatedMethods.Contains(methodName))
            {
                continue;
            }

            generatedMethods.Add(methodName);

            try
            {
                GenerateSingleRelatedDataMethod(sb, childTable, entityName, pkType, pkColumn.Name, rootNamespace);
            }
            catch
            {
                // Skip relationships that cannot be generated
            }
        }
    }

    /// <summary>
    /// Generates a single GetRelated method implementation.
    /// </summary>
    private static void GenerateSingleRelatedDataMethod(
        StringBuilder sb,
        Table childTable,
        string parentEntityName,
        string pkType,
        string pkColumnName,
        string rootNamespace)
    {
        // IMPORTANT: Use childTable.Name directly (not GetClassName) to match interface generator
        string childrenName = Pluralize(childTable.Name);
        string childEntityName = GetClassName(childTable.Name);
        string qualifiedChildEntityName = GetQualifiedEntityName(childEntityName, rootNamespace);
        string methodName = $"Get{childrenName}Async";
        string spName = $"SP_Get{parentEntityName}{childrenName}";
        string parentIdParamName = ToCamelCase(parentEntityName) + "Id";

        // XML Documentation
        sb.AppendLine("    /// <inheritdoc/>");

        // Method signature
        sb.AppendLine(
            CultureInfo.InvariantCulture,
            $"    public async System.Threading.Tasks.Task<IEnumerable<{qualifiedChildEntityName}>> {methodName}({pkType} {parentIdParamName}, int? skip = null, int? take = null, CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        sb.AppendLine(
            CultureInfo.InvariantCulture,
            $"        _logger.LogDebug(\"Fetching {childrenName.ToUpper(CultureInfo.InvariantCulture)} for {parentEntityName} ID: {{{parentEntityName}Id}}\", {parentIdParamName});");
        sb.AppendLine();
        sb.AppendLine("        try");
        sb.AppendLine("        {");

        // Build DynamicParameters
        sb.AppendLine("            var parameters = new DynamicParameters();");
        sb.AppendLine(CultureInfo.InvariantCulture, $"            parameters.Add(\"@{pkColumnName}\", {parentIdParamName});");
        sb.AppendLine("            parameters.Add(\"@Skip\", skip);");
        sb.AppendLine("            parameters.Add(\"@Take\", take);");
        sb.AppendLine();

        // Dapper call
        sb.AppendLine(CultureInfo.InvariantCulture, $"            var result = await _connection.QueryAsync<{qualifiedChildEntityName}>(");
        sb.AppendLine(CultureInfo.InvariantCulture, $"                \"{spName}\",");
        sb.AppendLine("                parameters,");
        sb.AppendLine("                commandType: CommandType.StoredProcedure);");
        sb.AppendLine();

        // Logging
        var logMessage = $"            _logger.LogInformation(\"Retrieved {{Count}} {childrenName.ToUpper(CultureInfo.InvariantCulture)} for {parentEntityName} ID: {{{parentEntityName}Id}}\", " +
            $"result.Count(), {parentIdParamName});";
        sb.AppendLine(logMessage);
        sb.AppendLine();
        sb.AppendLine("            return result;");
        sb.AppendLine("        }");
        sb.AppendLine("        catch (Exception ex)");
        sb.AppendLine("        {");
        sb.AppendLine(
            CultureInfo.InvariantCulture,
            $"            _logger.LogError(ex, \"Error fetching {childrenName.ToUpper(CultureInfo.InvariantCulture)} for {parentEntityName} ID: {{{parentEntityName}Id}}\", {parentIdParamName});");
        sb.AppendLine("            throw;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    /// <summary>
    /// Pluralizes a singular noun using simple English rules.
    /// </summary>
    private static string Pluralize(string singular)
    {
        if (string.IsNullOrEmpty(singular))
        {
            return singular;
        }

        // Category → Categories
        // CA1867: String literals required here because char overload doesn't support StringComparison
#pragma warning disable CA1867
        if (singular.EndsWith("y", StringComparison.OrdinalIgnoreCase) &&
            !singular.EndsWith("ay", StringComparison.OrdinalIgnoreCase) &&
            !singular.EndsWith("ey", StringComparison.OrdinalIgnoreCase) &&
            !singular.EndsWith("oy", StringComparison.OrdinalIgnoreCase) &&
            !singular.EndsWith("uy", StringComparison.OrdinalIgnoreCase))
        {
            return singular[..^1] + "ies";
        }

        // Address → Addresses, Box → Boxes
        if (singular.EndsWith("s", StringComparison.OrdinalIgnoreCase) ||
            singular.EndsWith("x", StringComparison.OrdinalIgnoreCase) ||
            singular.EndsWith("z", StringComparison.OrdinalIgnoreCase) ||
            singular.EndsWith("ch", StringComparison.OrdinalIgnoreCase) ||
            singular.EndsWith("sh", StringComparison.OrdinalIgnoreCase))
#pragma warning restore CA1867
        {
            return singular + "es";
        }

        // Order → Orders, Customer → Customers
        return singular + "s";
    }

    /// <summary>
    /// Converts a string to camelCase.
    /// </summary>
    private static string ToCamelCase(string value)
    {
        if (string.IsNullOrEmpty(value))
        {
            return value;
        }

        return char.ToLowerInvariant(value[0]) + value[1..];
    }

    /// <summary>
    /// Ensures the table has a primary key. For VIEWs, infers an identifier column.
    /// </summary>
    /// <param name="table">The table to validate.</param>
    /// <exception cref="InvalidOperationException">Thrown when no primary key can be determined.</exception>
    private static void EnsurePrimaryKey(Table table)
    {
        if (table.PrimaryKeyColumns != null && table.PrimaryKeyColumns.Count > 0)
        {
            return; // Already has PK
        }

        if (!table.IsView)
        {
            throw new InvalidOperationException($"Table '{table.Name}' must have a primary key defined.");
        }

        // For VIEWs: infer identifier column (ID column or first column)
        var idColumn = FindIdentifierColumn(table);
        if (idColumn == null)
        {
            throw new InvalidOperationException($"VIEW '{table.Name}' has no columns to use as identifier.");
        }

        table.PrimaryKeyColumns = new List<string> { idColumn.Name };
        idColumn.IsPrimaryKey = true;
    }

    /// <summary>
    /// Finds a suitable identifier column for a VIEW (ID column or first column).
    /// </summary>
    private static Column? FindIdentifierColumn(Table table)
    {
        if (table.Columns.Count == 0)
        {
            return null;
        }

        // Try to find column named "ID" (case-insensitive)
        var idColumn = table.Columns.Find(c => c.Name.Equals("ID", StringComparison.OrdinalIgnoreCase));
        if (idColumn != null)
        {
            return idColumn;
        }

        // Try to find column ending with "ID" (e.g., CustomerID, OrderID)
        idColumn = table.Columns.Find(c => c.Name.EndsWith("ID", StringComparison.OrdinalIgnoreCase));
        if (idColumn != null)
        {
            return idColumn;
        }

        // Fallback: use first column
        return table.Columns[0];
    }

    /// <summary>
    /// Gets the class name for an entity from the table name.
    /// Uses the same PascalCase conversion as API generators for consistency.
    /// </summary>
    private static string GetClassName(string tableName)
    {
        return TargCC.Core.Generators.API.BaseApiGenerator.GetClassName(tableName);
    }

    /// <summary>
    /// Gets a qualified entity name that avoids naming conflicts with system types.
    /// </summary>
    /// <param name="entityName">The entity class name.</param>
    /// <param name="rootNamespace">The root namespace of the project.</param>
    /// <returns>Fully qualified entity name if there's a conflict, otherwise just the entity name.</returns>
    private static string GetQualifiedEntityName(string entityName, string rootNamespace)
    {
        // Check if entity name conflicts with common .NET types
        var conflictingTypes = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "Task",      // System.Threading.Tasks.Task
            "Action",    // System.Action
            "Func",      // System.Func
            "Exception", // System.Exception
            "Attribute", // System.Attribute
            "Object",    // System.Object
            "String",    // System.String
            "Thread",    // System.Threading.Thread
            "Timer",     // System.Threading.Timer
            "File",      // System.IO.File
            "Directory", // System.IO.Directory
            "Stream",    // System.IO.Stream
        };

        if (conflictingTypes.Contains(entityName))
        {
            return $"{rootNamespace}.Domain.Entities.{entityName}";
        }

        return entityName;
    }

    /// <summary>
    /// Closes the class declaration.
    /// </summary>
    private static void CloseClass(StringBuilder sb)
    {
        sb.AppendLine("}");
    }
}
