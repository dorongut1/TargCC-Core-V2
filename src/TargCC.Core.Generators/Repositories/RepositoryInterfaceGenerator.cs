namespace TargCC.Core.Generators.Repositories;

using System.Globalization;
using System.Text;
using Microsoft.Extensions.Logging;
using TargCC.Core.Generators.Common;
using TargCC.Core.Interfaces.Models;

/// <summary>
/// Generates repository interface code from database table metadata for Clean Architecture pattern.
/// </summary>
/// <remarks>
/// <para>
/// This generator creates strongly-typed repository interfaces that define the contract for
/// data access operations. The generated interfaces are placed in the Domain layer and
/// implemented in the Infrastructure layer, following the Dependency Inversion Principle.
/// </para>
/// <para>
/// <strong>Architecture Pattern:</strong>
/// </para>
/// <code>
/// Domain Layer (this generator)
///   └── Interfaces/
///       └── ICustomerRepository.cs  ← Generated interface
///
/// Infrastructure Layer (RepositoryGenerator)
///   └── Repositories/
///       └── CustomerRepository.cs  ← Implements ICustomerRepository
/// </code>
/// <para>
/// <strong>Generated Methods by Table Features:</strong>
/// </para>
/// <list type="table">
/// <listheader><term>Table Feature</term><description>Generated Method</description></listheader>
/// <item><term>Primary Key</term><description>GetByIdAsync(pkType id)</description></item>
/// <item><term>Unique Index</term><description>GetByXXXAsync(type value) - returns single entity</description></item>
/// <item><term>Non-Unique Index</term><description>GetByXXXAsync(type value) - returns IEnumerable</description></item>
/// <item><term>agg_ columns</term><description>UpdateAggregatesAsync(...)</description></item>
/// <item><term>Always</term><description>GetAllAsync, AddAsync, UpdateAsync, DeleteAsync, ExistsAsync</description></item>
/// </list>
/// </remarks>
public class RepositoryInterfaceGenerator : IRepositoryInterfaceGenerator
{
    // LoggerMessage delegates for performance
    private static readonly Action<ILogger, string, Exception?> LogGeneratingInterface =
        LoggerMessage.Define<string>(
            LogLevel.Information,
            new EventId(1, nameof(GenerateAsync)),
            "Generating repository interface for table: {TableName}");

    private static readonly Action<ILogger, string, Exception?> LogSuccessfullyGenerated =
        LoggerMessage.Define<string>(
            LogLevel.Information,
            new EventId(2, nameof(GenerateAsync)),
            "Successfully generated repository interface for table: {TableName}");

    private readonly ILogger<RepositoryInterfaceGenerator> _logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="RepositoryInterfaceGenerator"/> class.
    /// </summary>
    /// <param name="logger">Logger for tracking generation process.</param>
    public RepositoryInterfaceGenerator(ILogger<RepositoryInterfaceGenerator> logger)
    {
        ArgumentNullException.ThrowIfNull(logger);
        _logger = logger;
    }

    /// <inheritdoc/>
    public async Task<string> GenerateAsync(Table table, string rootNamespace = "YourApp")
    {
        return await GenerateAsync(table, null, rootNamespace);
    }

    /// <inheritdoc/>
    public async Task<string> GenerateAsync(Table table, DatabaseSchema? schema, string rootNamespace = "YourApp")
    {
        ArgumentNullException.ThrowIfNull(table);

        // Ensure table has a primary key (infers identifier for VIEWs)
        EnsurePrimaryKey(table);

        LogGeneratingInterface(_logger, table.Name, null);

        var sb = new StringBuilder();

        // Add file header
        GenerateFileHeader(sb, table);

        // Add namespace and using statements
        GenerateUsings(sb, rootNamespace);

        // Start interface
        StartInterface(sb, table);

        // Generate CRUD methods
        GenerateCrudMethods(sb, table, rootNamespace);

        // Generate index-based query methods
        GenerateIndexBasedMethods(sb, table, rootNamespace);

        // Generate aggregate methods if needed
        GenerateAggregateMethods(sb, table, rootNamespace);

        // Generate related data methods (Master-Detail Views)
        if (schema != null)
        {
            GenerateRelatedDataMethods(sb, table, schema, rootNamespace);
        }

        // Generate helper methods
        GenerateHelperMethods(sb, table, rootNamespace);

        // Close interface
        CloseInterface(sb);

        LogSuccessfullyGenerated(_logger, table.Name, null);

        return await Task.FromResult(sb.ToString());
    }

    /// <summary>
    /// Generates the file header with XML documentation.
    /// </summary>
    private static void GenerateFileHeader(StringBuilder sb, Table table)
    {
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("//     This code was generated by TargCC.Core.Generators v2.0");
        sb.AppendLine(CultureInfo.InvariantCulture, $"//     Generated from table: {table.FullName}");
        sb.AppendLine(CultureInfo.InvariantCulture, $"//     Generation date: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        sb.AppendLine("//");
        sb.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
        sb.AppendLine("//     the code is regenerated.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates using statements.
    /// </summary>
    private static void GenerateUsings(StringBuilder sb, string rootNamespace)
    {
        sb.AppendLine(CultureInfo.InvariantCulture, $"namespace {rootNamespace}.Domain.Interfaces;");
        sb.AppendLine();
        sb.AppendLine(CultureInfo.InvariantCulture, $"using {rootNamespace}.Domain.Entities;");
        sb.AppendLine();
    }

    /// <summary>
    /// Starts the interface declaration with XML documentation.
    /// </summary>
    private static void StartInterface(StringBuilder sb, Table table)
    {
        string entityName = GetClassName(table.Name);
        string interfaceName = $"I{entityName}Repository";

        sb.AppendLine("/// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"/// Repository interface for {entityName} entity data access operations.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine("/// <para>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"/// This interface defines the contract for data access operations on the {entityName} entity.");
        sb.AppendLine("/// It follows the Repository pattern and is implemented in the Infrastructure layer.");
        sb.AppendLine("/// </para>");
        sb.AppendLine("/// <para>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"/// <strong>Implementation:</strong> See <c>{entityName}Repository</c> in Infrastructure layer.");
        sb.AppendLine("/// </para>");
        sb.AppendLine("/// </remarks>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"public interface {interfaceName}");
        sb.AppendLine("{");
    }

    /// <summary>
    /// Generates CRUD methods (Create, Read, Update, Delete).
    /// </summary>
    private static void GenerateCrudMethods(StringBuilder sb, Table table, string rootNamespace)
    {
        string entityName = GetClassName(table.Name);
        string qualifiedEntityName = GetQualifiedEntityName(entityName, rootNamespace);
        var pkColumn = table.Columns.Find(c => c.IsPrimaryKey);

        if (pkColumn == null)
        {
            throw new InvalidOperationException($"Table '{table.Name}' has no primary key column.");
        }

        string pkType = GetCSharpType(pkColumn.DataType);

        // GetByIdAsync
        sb.AppendLine("    /// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Gets a {entityName} entity by its primary key.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"id\">The primary key value.</param>");
        sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <returns>The {entityName} entity if found; otherwise, null.</returns>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    System.Threading.Tasks.Task<{qualifiedEntityName}?> GetByIdAsync({pkType} id, CancellationToken cancellationToken = default);");
        sb.AppendLine();

        // GetAllAsync
        sb.AppendLine("    /// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Gets all {entityName} entities with optional filtering and paging.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"skip\">Number of entities to skip (for paging).</param>");
        sb.AppendLine("    /// <param name=\"take\">Number of entities to take (for paging).</param>");
        sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <returns>Collection of {entityName} entities.</returns>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    System.Threading.Tasks.Task<IEnumerable<{qualifiedEntityName}>> GetAllAsync(int? skip = null, int? take = null, CancellationToken cancellationToken = default);");
        sb.AppendLine();

        // GetFilteredAsync (if indexes exist)
        GenerateGetFilteredAsyncMethod(sb, table, rootNamespace);

        // Only generate Add/Update/Delete for tables, not for views (views are read-only)
        if (!table.IsView)
        {
            // AddAsync
            sb.AppendLine("    /// <summary>");
            sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Adds a new {entityName} entity to the database.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <param name=\"entity\">The {entityName} entity to add.</param>");
            sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
            sb.AppendLine("    /// <returns>A task representing the asynchronous operation.</returns>");
            sb.AppendLine(CultureInfo.InvariantCulture, $"    System.Threading.Tasks.Task AddAsync({qualifiedEntityName} entity, CancellationToken cancellationToken = default);");
            sb.AppendLine();

            // UpdateAsync
            sb.AppendLine("    /// <summary>");
            sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Updates an existing {entityName} entity in the database.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <param name=\"entity\">The {entityName} entity to update.</param>");
            sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
            sb.AppendLine("    /// <returns>A task representing the asynchronous operation.</returns>");
            sb.AppendLine(CultureInfo.InvariantCulture, $"    System.Threading.Tasks.Task UpdateAsync({qualifiedEntityName} entity, CancellationToken cancellationToken = default);");
            sb.AppendLine();

            // DeleteAsync
            sb.AppendLine("    /// <summary>");
            sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Deletes a {entityName} entity from the database.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    /// <param name=\"id\">The primary key value of the entity to delete.</param>");
            sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
            sb.AppendLine("    /// <returns>A task representing the asynchronous operation.</returns>");
            sb.AppendLine(CultureInfo.InvariantCulture, $"    System.Threading.Tasks.Task DeleteAsync({pkType} id, CancellationToken cancellationToken = default);");
            sb.AppendLine();
        }
    }

    /// <summary>
    /// Generates index-based query methods.
    /// </summary>
    private static void GenerateIndexBasedMethods(StringBuilder sb, Table table, string rootNamespace)
    {
        if (table.Indexes == null || table.Indexes.Count == 0)
        {
            return;
        }

        string entityName = GetClassName(table.Name);
        string qualifiedEntityName = GetQualifiedEntityName(entityName, rootNamespace);

        // Track generated method signatures to avoid duplicates
        var generatedMethods = new HashSet<string>();

        // Process unique indexes first (they take precedence)
        var sortedIndexes = table.Indexes
            .Where(i => !i.IsPrimaryKey)
            .OrderByDescending(i => i.IsUnique) // Unique indexes first
            .ToList();

        // Process each non-primary key index
        foreach (var index in sortedIndexes)
        {
            if (index.ColumnNames == null || index.ColumnNames.Count == 0)
            {
                continue;
            }

            // Build method name from index columns using LINQ
            string methodName = "GetBy" + string.Join("And", index.ColumnNames.Select(CodeGenerationHelpers.SanitizeColumnName));

            // Skip if we already generated a method with this name (happens when both unique and non-unique indexes exist on same columns)
            if (generatedMethods.Contains(methodName))
            {
                continue;
            }

            generatedMethods.Add(methodName);

            // Build parameter list using LINQ
            var parameters = index.ColumnNames
                .Select(columnName => table.Columns.Find(c => c.Name == columnName))
                .Where(column => column != null)
                .Select(column => $"{GetCSharpType(column!.DataType)} {CodeGenerationHelpers.ToCamelCase(CodeGenerationHelpers.SanitizeColumnName(column.Name))}")
                .ToList();

            string paramList = string.Join(", ", parameters);

            // Generate method
            sb.AppendLine("    /// <summary>");
            if (index.IsUnique)
            {
                sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Gets a {entityName} entity by {string.Join(" and ", index.ColumnNames)}.");
                sb.AppendLine("    /// </summary>");

                // Generate param docs using LINQ
                var paramDocs = index.ColumnNames
                    .Select(columnName => table.Columns.Find(c => c.Name == columnName))
                    .Where(column => column != null)
                    .Select(column => (paramName: CodeGenerationHelpers.ToCamelCase(CodeGenerationHelpers.SanitizeColumnName(column!.Name)),
                                       sanitized: CodeGenerationHelpers.SanitizeColumnName(column.Name)));

                foreach (var (paramName, sanitized) in paramDocs)
                {
                    sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <param name=\"{paramName}\">The {sanitized} value to search for.</param>");
                }

                sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
                sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <returns>The {entityName} entity if found; otherwise, null.</returns>");
                sb.AppendLine(CultureInfo.InvariantCulture, $"    System.Threading.Tasks.Task<{qualifiedEntityName}?> {methodName}Async({paramList}, CancellationToken cancellationToken = default);");
            }
            else
            {
                sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Gets all {entityName} entities matching the specified {string.Join(" and ", index.ColumnNames)}.");
                sb.AppendLine("    /// </summary>");

                // Generate param docs using LINQ
                var paramDocs = index.ColumnNames
                    .Select(columnName => table.Columns.Find(c => c.Name == columnName))
                    .Where(column => column != null)
                    .Select(column => (paramName: CodeGenerationHelpers.ToCamelCase(CodeGenerationHelpers.SanitizeColumnName(column!.Name)),
                                       sanitized: CodeGenerationHelpers.SanitizeColumnName(column.Name)));

                foreach (var (paramName, sanitized) in paramDocs)
                {
                    sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <param name=\"{paramName}\">The {sanitized} value to filter by.</param>");
                }

                sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
                sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <returns>Collection of {entityName} entities matching the criteria.</returns>");
                sb.AppendLine(CultureInfo.InvariantCulture, $"    System.Threading.Tasks.Task<IEnumerable<{qualifiedEntityName}>> {methodName}Async({paramList}, CancellationToken cancellationToken = default);");
            }

            sb.AppendLine();
        }
    }

    /// <summary>
    /// Generates aggregate update methods for tables with agg_ columns.
    /// </summary>
    private static void GenerateAggregateMethods(StringBuilder sb, Table table, string rootNamespace)
    {
        _ = rootNamespace; // Not used - UpdateAggregatesAsync only uses primitive types in parameters

        // Find aggregate columns (agg_ prefix)
        var aggColumns = table.Columns
            .Where(c => c.Name.StartsWith("agg_", StringComparison.OrdinalIgnoreCase))
            .ToList();

        if (aggColumns.Count == 0)
        {
            return;
        }

        string entityName = GetClassName(table.Name);
        var pkColumn = table.Columns.Find(c => c.IsPrimaryKey);

        if (pkColumn == null)
        {
            return;
        }

        string pkType = GetCSharpType(pkColumn.DataType);

        // Build parameter list for aggregate columns using LINQ
        var parameters = new List<string> { $"{pkType} id" };
        parameters.AddRange(
            aggColumns.Select(column =>
                $"{GetCSharpType(column.DataType)} {CodeGenerationHelpers.ToCamelCase(CodeGenerationHelpers.SanitizeColumnName(column.Name))}"));

        string paramList = string.Join(", ", parameters);

        sb.AppendLine("    /// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Updates aggregate columns for a {entityName} entity.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <remarks>");
        sb.AppendLine("    /// <para>");
        sb.AppendLine("    /// Aggregate columns (agg_ prefix) store calculated values like counts and totals.");
        sb.AppendLine("    /// This method provides a dedicated way to update these values efficiently.");
        sb.AppendLine("    /// </para>");
        sb.AppendLine("    /// </remarks>");
        sb.AppendLine("    /// <param name=\"id\">The primary key value.</param>");

        // Generate param docs using LINQ
        var aggParamDocs = aggColumns.Select(column =>
            (paramName: CodeGenerationHelpers.ToCamelCase(CodeGenerationHelpers.SanitizeColumnName(column.Name)),
             sanitized: CodeGenerationHelpers.SanitizeColumnName(column.Name)));

        foreach (var (paramName, sanitized) in aggParamDocs)
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <param name=\"{paramName}\">New value for {sanitized}.</param>");
        }

        sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
        sb.AppendLine("    /// <returns>A task representing the asynchronous operation.</returns>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    System.Threading.Tasks.Task UpdateAggregatesAsync({paramList}, CancellationToken cancellationToken = default);");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates GetFilteredAsync method based on table indexes.
    /// </summary>
    private static void GenerateGetFilteredAsyncMethod(StringBuilder sb, Table table, string rootNamespace)
    {
        var filterableIndexes = table.Indexes?
            .Where(i => !i.IsPrimaryKey && i.ColumnNames != null && i.ColumnNames.Count > 0)
            .ToList();

        if (filterableIndexes == null || filterableIndexes.Count == 0)
        {
            // No filterable indexes, skip
            return;
        }

        string entityName = GetClassName(table.Name);
        string qualifiedEntityName = GetQualifiedEntityName(entityName, rootNamespace);
        var parameters = new List<(string paramName, string paramType, string columnName)>();

        // Collect unique indexed columns
        var processedColumns = new HashSet<string>();
        foreach (var index in filterableIndexes)
        {
            foreach (var columnName in index.ColumnNames)
            {
                if (processedColumns.Contains(columnName))
                {
                    continue;
                }

                processedColumns.Add(columnName);
                var column = table.Columns.Find(c => c.Name == columnName);
                if (column != null)
                {
                    string paramName = CodeGenerationHelpers.ToCamelCase(CodeGenerationHelpers.SanitizeColumnName(columnName));
                    string paramType = GetCSharpType(column.DataType) + "?"; // Nullable
                    parameters.Add((paramName, paramType, columnName));
                }
            }
        }

        if (parameters.Count == 0)
        {
            return;
        }

        // XML Documentation
        sb.AppendLine("    /// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Gets filtered {entityName} entities based on indexed columns.");
        sb.AppendLine("    /// </summary>");

        foreach (var (paramName, _, columnName) in parameters)
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <param name=\"{paramName}\">Filter by {columnName} (optional).</param>");
        }

        sb.AppendLine("    /// <param name=\"skip\">Number of entities to skip (for paging).</param>");
        sb.AppendLine("    /// <param name=\"take\">Number of entities to take (for paging).</param>");
        sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <returns>Collection of filtered {entityName} entities.</returns>");

        // Method signature
        var paramList = string.Join(
            ", ",
            parameters.Select(p => $"{p.paramType} {p.paramName} = null")
            .Concat(["int? skip = null", "int? take = null", "CancellationToken cancellationToken = default"]));

        sb.AppendLine(CultureInfo.InvariantCulture, $"    System.Threading.Tasks.Task<IEnumerable<{qualifiedEntityName}>> GetFilteredAsync({paramList});");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates helper methods like ExistsAsync.
    /// </summary>
    private static void GenerateHelperMethods(StringBuilder sb, Table table, string rootNamespace)
    {
        _ = rootNamespace; // Not used - ExistsAsync only returns bool, not entity types
        string entityName = GetClassName(table.Name);
        var pkColumn = table.Columns.Find(c => c.IsPrimaryKey);

        if (pkColumn == null)
        {
            return;
        }

        string pkType = GetCSharpType(pkColumn.DataType);

        // ExistsAsync
        sb.AppendLine("    /// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Checks if a {entityName} entity exists with the specified primary key.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"id\">The primary key value to check.</param>");
        sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
        sb.AppendLine("    /// <returns>True if the entity exists; otherwise, false.</returns>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    System.Threading.Tasks.Task<bool> ExistsAsync({pkType} id, CancellationToken cancellationToken = default);");
    }

    /// <summary>
    /// Generates methods for fetching related data (Master-Detail Views) based on FK relationships.
    /// </summary>
    private static void GenerateRelatedDataMethods(StringBuilder sb, Table table, DatabaseSchema schema, string rootNamespace)
    {
        if (schema.Relationships == null || schema.Relationships.Count == 0)
        {
            return;
        }

        // Find all relationships where this table is the parent
        var parentRelationships = schema.Relationships
            .Where(r => r.ParentTable == table.FullName && r.IsEnabled)
            .ToList();

        if (parentRelationships.Count == 0)
        {
            return;
        }

        sb.AppendLine("    // ======================================");
        sb.AppendLine("    // Master-Detail Views (Related Data)");
        sb.AppendLine("    // ======================================");
        sb.AppendLine();

        // Track generated methods to avoid duplicates when multiple FKs point to same child table
        var generatedMethods = new HashSet<string>();

        foreach (var relationship in parentRelationships)
        {
            var childTable = schema.Tables.Find(t => t.FullName == relationship.ChildTable);
            if (childTable == null)
            {
                continue;
            }

            var pkColumn = table.Columns.Find(c => c.IsPrimaryKey);
            if (pkColumn == null)
            {
                continue;
            }

            var pkType = GetCSharpType(pkColumn.DataType);
            var childrenName = CodeGenerationHelpers.MakePlural(childTable.Name);
            var methodName = $"Get{childrenName}Async";

            // Skip if we've already generated this method (happens with multiple FKs to same table)
            if (generatedMethods.Contains(methodName))
            {
                continue;
            }

            generatedMethods.Add(methodName);

            string childEntityName = GetClassName(childTable.Name);
            string qualifiedChildEntityName = GetQualifiedEntityName(childEntityName, rootNamespace);

            // Generate XML documentation
            sb.AppendLine("    /// <summary>");
            sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Fetches all {childrenName.ToLower(CultureInfo.CurrentCulture)} for the specified {table.Name.ToLower(CultureInfo.CurrentCulture)}.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <param name=\"{ToCamelCase(table.Name)}Id\">The {table.Name} ID.</param>");
            sb.AppendLine("    /// <param name=\"skip\">Number of records to skip (for pagination).</param>");
            sb.AppendLine("    /// <param name=\"take\">Number of records to take (for pagination).</param>");
            sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
            sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <returns>A collection of {childEntityName} entities.</returns>");

            // Generate method signature
            var methodSignature = $"    System.Threading.Tasks.Task<IEnumerable<{qualifiedChildEntityName}>> {methodName}({pkType} {ToCamelCase(table.Name)}Id, " +
                $"int? skip = null, int? take = null, CancellationToken cancellationToken = default);";
            sb.AppendLine(methodSignature);
            sb.AppendLine();
        }
    }

    /// <summary>
    /// Closes the interface declaration.
    /// </summary>
    private static void CloseInterface(StringBuilder sb)
    {
        sb.AppendLine("}");
    }

    /// <summary>
    /// Converts PascalCase to camelCase.
    /// </summary>
    private static string ToCamelCase(string pascalCase)
    {
        if (string.IsNullOrEmpty(pascalCase))
        {
            return pascalCase;
        }

        return char.ToLowerInvariant(pascalCase[0]) + pascalCase[1..];
    }

    /// <summary>
    /// Maps SQL data types to C# types.
    /// </summary>
    private static string GetCSharpType(string sqlType)
    {
        return sqlType.ToUpperInvariant() switch
        {
            "INT" => "int",
            "BIGINT" => "long",
            "SMALLINT" => "short",
            "TINYINT" => "byte",
            "BIT" => "bool",
            "DECIMAL" or "NUMERIC" or "MONEY" or "SMALLMONEY" => "decimal",
            "FLOAT" => "double",
            "REAL" => "float",
            "DATETIME" or "DATETIME2" or "DATE" or "SMALLDATETIME" => "DateTime",
            "TIME" => "TimeSpan",
            "DATETIMEOFFSET" => "DateTimeOffset",
            "UNIQUEIDENTIFIER" => "Guid",
            "VARCHAR" or "NVARCHAR" or "CHAR" or "NCHAR" or "TEXT" or "NTEXT" => "string",
            "VARBINARY" or "BINARY" or "IMAGE" => "byte[]",
            _ => "string"
        };
    }

    /// <summary>
    /// Ensures the table has a primary key. For VIEWs, infers an identifier column.
    /// </summary>
    /// <param name="table">The table to validate.</param>
    /// <exception cref="InvalidOperationException">Thrown when no primary key can be determined.</exception>
    private static void EnsurePrimaryKey(Table table)
    {
        if (table.PrimaryKeyColumns != null && table.PrimaryKeyColumns.Count > 0)
        {
            return; // Already has PK
        }

        if (!table.IsView)
        {
            throw new InvalidOperationException($"Table '{table.Name}' must have a primary key defined.");
        }

        // For VIEWs: infer identifier column (ID column or first column)
        var idColumn = FindIdentifierColumn(table);
        if (idColumn == null)
        {
            throw new InvalidOperationException($"VIEW '{table.Name}' has no columns to use as identifier.");
        }

        table.PrimaryKeyColumns = new List<string> { idColumn.Name };
        idColumn.IsPrimaryKey = true;
    }

    /// <summary>
    /// Finds a suitable identifier column for a VIEW (ID column or first column).
    /// </summary>
    private static Column? FindIdentifierColumn(Table table)
    {
        if (table.Columns.Count == 0)
        {
            return null;
        }

        // Try to find column named exactly "ID" or "Id" (case-insensitive)
        var idColumn = table.Columns.Find(c =>
            c.Name.Equals("ID", StringComparison.OrdinalIgnoreCase) ||
            c.Name.Equals("Id", StringComparison.OrdinalIgnoreCase));
        if (idColumn != null && IsIntegerType(idColumn.DataType))
        {
            return idColumn;
        }

        // Try to find column ending with "ID" or "Id" that is an integer type (e.g., CustomerID, OrderID)
        idColumn = table.Columns.Find(c =>
            c.Name.EndsWith("ID", StringComparison.OrdinalIgnoreCase) &&
            IsIntegerType(c.DataType));
        if (idColumn != null)
        {
            return idColumn;
        }

        // Try to find any column named "ID" even if not integer type
        idColumn = table.Columns.Find(c => c.Name.Equals("ID", StringComparison.OrdinalIgnoreCase));
        if (idColumn != null)
        {
            return idColumn;
        }

        // Fallback: use first integer column
        var firstIntColumn = table.Columns.Find(c => IsIntegerType(c.DataType));
        if (firstIntColumn != null)
        {
            return firstIntColumn;
        }

        // Last resort: use first column
        return table.Columns[0];
    }

    /// <summary>
    /// Checks if a SQL data type is an integer type.
    /// </summary>
    private static bool IsIntegerType(string dataType)
    {
        if (string.IsNullOrEmpty(dataType))
        {
            return false;
        }

        var upper = dataType.ToUpperInvariant();
        return upper.Contains("INT", StringComparison.Ordinal) && !upper.Contains("POINT", StringComparison.Ordinal);
    }

    /// <summary>
    /// Gets the class name for an entity from the table name.
    /// Uses the same PascalCase conversion as API generators for consistency.
    /// </summary>
    private static string GetClassName(string tableName)
    {
        return TargCC.Core.Generators.API.BaseApiGenerator.GetClassName(tableName);
    }

    /// <summary>
    /// Gets a qualified entity name that avoids naming conflicts with system types.
    /// </summary>
    /// <param name="entityName">The entity class name.</param>
    /// <param name="rootNamespace">The root namespace of the project.</param>
    /// <returns>Fully qualified entity name if there's a conflict, otherwise just the entity name.</returns>
    private static string GetQualifiedEntityName(string entityName, string rootNamespace)
    {
        // Check if entity name conflicts with common .NET types
        var conflictingTypes = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
        {
            "Task",      // System.Threading.Tasks.Task
            "Action",    // System.Action
            "Func",      // System.Func
            "Exception", // System.Exception
            "Attribute", // System.Attribute
            "Object",    // System.Object
            "String",    // System.String
            "Thread",    // System.Threading.Thread
            "Timer",     // System.Threading.Timer
            "File",      // System.IO.File
            "Directory", // System.IO.Directory
            "Stream",    // System.IO.Stream
        };

        if (conflictingTypes.Contains(entityName))
        {
            return $"{rootNamespace}.Domain.Entities.{entityName}";
        }

        return entityName;
    }
}
