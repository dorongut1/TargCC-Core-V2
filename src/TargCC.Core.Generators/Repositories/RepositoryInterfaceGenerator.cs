namespace TargCC.Core.Generators.Repositories;

using System.Globalization;
using System.Text;
using Microsoft.Extensions.Logging;
using TargCC.Core.Generators.Common;
using TargCC.Core.Interfaces.Models;

/// <summary>
/// Generates repository interface code from database table metadata for Clean Architecture pattern.
/// </summary>
/// <remarks>
/// <para>
/// This generator creates strongly-typed repository interfaces that define the contract for
/// data access operations. The generated interfaces are placed in the Domain layer and
/// implemented in the Infrastructure layer, following the Dependency Inversion Principle.
/// </para>
/// <para>
/// <strong>Architecture Pattern:</strong>
/// </para>
/// <code>
/// Domain Layer (this generator)
///   └── Interfaces/
///       └── ICustomerRepository.cs  ← Generated interface
///
/// Infrastructure Layer (RepositoryGenerator)
///   └── Repositories/
///       └── CustomerRepository.cs  ← Implements ICustomerRepository
/// </code>
/// <para>
/// <strong>Generated Methods by Table Features:</strong>
/// </para>
/// <list type="table">
/// <listheader><term>Table Feature</term><description>Generated Method</description></listheader>
/// <item><term>Primary Key</term><description>GetByIdAsync(pkType id)</description></item>
/// <item><term>Unique Index</term><description>GetByXXXAsync(type value) - returns single entity</description></item>
/// <item><term>Non-Unique Index</term><description>GetByXXXAsync(type value) - returns IEnumerable</description></item>
/// <item><term>agg_ columns</term><description>UpdateAggregatesAsync(...)</description></item>
/// <item><term>Always</term><description>GetAllAsync, AddAsync, UpdateAsync, DeleteAsync, ExistsAsync</description></item>
/// </list>
/// </remarks>
public class RepositoryInterfaceGenerator : IRepositoryInterfaceGenerator
{
    // LoggerMessage delegates for performance
    private static readonly Action<ILogger, string, Exception?> LogGeneratingInterface =
        LoggerMessage.Define<string>(
            LogLevel.Information,
            new EventId(1, nameof(GenerateAsync)),
            "Generating repository interface for table: {TableName}");

    private static readonly Action<ILogger, string, Exception?> LogSuccessfullyGenerated =
        LoggerMessage.Define<string>(
            LogLevel.Information,
            new EventId(2, nameof(GenerateAsync)),
            "Successfully generated repository interface for table: {TableName}");

    private readonly ILogger<RepositoryInterfaceGenerator> _logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="RepositoryInterfaceGenerator"/> class.
    /// </summary>
    /// <param name="logger">Logger for tracking generation process.</param>
    public RepositoryInterfaceGenerator(ILogger<RepositoryInterfaceGenerator> logger)
    {
        ArgumentNullException.ThrowIfNull(logger);
        _logger = logger;
    }

    /// <inheritdoc/>
    public async Task<string> GenerateAsync(Table table, string rootNamespace = "YourApp")
    {
        ArgumentNullException.ThrowIfNull(table);

        if (table.PrimaryKeyColumns == null || table.PrimaryKeyColumns.Count == 0)
        {
            throw new InvalidOperationException($"Table '{table.Name}' must have a primary key defined.");
        }

        LogGeneratingInterface(_logger, table.Name, null);

        var sb = new StringBuilder();

        // Add file header
        GenerateFileHeader(sb, table);

        // Add namespace and using statements
        GenerateUsings(sb, rootNamespace);

        // Start interface
        StartInterface(sb, table);

        // Generate CRUD methods
        GenerateCrudMethods(sb, table);

        // Generate index-based query methods
        GenerateIndexBasedMethods(sb, table);

        // Generate aggregate methods if needed
        GenerateAggregateMethods(sb, table);

        // Generate helper methods
        GenerateHelperMethods(sb, table);

        // Close interface
        CloseInterface(sb);

        LogSuccessfullyGenerated(_logger, table.Name, null);

        return await Task.FromResult(sb.ToString());
    }

    /// <summary>
    /// Generates the file header with XML documentation.
    /// </summary>
    private static void GenerateFileHeader(StringBuilder sb, Table table)
    {
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("//     This code was generated by TargCC.Core.Generators v2.0");
        sb.AppendLine(CultureInfo.InvariantCulture, $"//     Generated from table: {table.FullName}");
        sb.AppendLine(CultureInfo.InvariantCulture, $"//     Generation date: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        sb.AppendLine("//");
        sb.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
        sb.AppendLine("//     the code is regenerated.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates using statements.
    /// </summary>
    private static void GenerateUsings(StringBuilder sb, string rootNamespace)
    {
        sb.AppendLine(CultureInfo.InvariantCulture, $"namespace {rootNamespace}.Domain.Interfaces;");
        sb.AppendLine();
        sb.AppendLine(CultureInfo.InvariantCulture, $"using {rootNamespace}.Domain.Entities;");
        sb.AppendLine();
    }

    /// <summary>
    /// Starts the interface declaration with XML documentation.
    /// </summary>
    private static void StartInterface(StringBuilder sb, Table table)
    {
        string entityName = table.Name;
        string interfaceName = $"I{entityName}Repository";

        sb.AppendLine("/// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"/// Repository interface for {entityName} entity data access operations.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine("/// <para>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"/// This interface defines the contract for data access operations on the {entityName} entity.");
        sb.AppendLine("/// It follows the Repository pattern and is implemented in the Infrastructure layer.");
        sb.AppendLine("/// </para>");
        sb.AppendLine("/// <para>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"/// <strong>Implementation:</strong> See <c>{entityName}Repository</c> in Infrastructure layer.");
        sb.AppendLine("/// </para>");
        sb.AppendLine("/// </remarks>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"public interface {interfaceName}");
        sb.AppendLine("{");
    }

    /// <summary>
    /// Generates CRUD methods (Create, Read, Update, Delete).
    /// </summary>
    private static void GenerateCrudMethods(StringBuilder sb, Table table)
    {
        string entityName = table.Name;
        var pkColumn = table.Columns.Find(c => c.IsPrimaryKey);

        if (pkColumn == null)
        {
            throw new InvalidOperationException($"Table '{table.Name}' has no primary key column.");
        }

        string pkType = GetCSharpType(pkColumn.DataType);

        // GetByIdAsync
        sb.AppendLine("    /// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Gets a {entityName} entity by its primary key.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"id\">The primary key value.</param>");
        sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <returns>The {entityName} entity if found; otherwise, null.</returns>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    Task<{entityName}?> GetByIdAsync({pkType} id, CancellationToken cancellationToken = default);");
        sb.AppendLine();

        // GetAllAsync
        sb.AppendLine("    /// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Gets all {entityName} entities with optional filtering and paging.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"skip\">Number of entities to skip (for paging).</param>");
        sb.AppendLine("    /// <param name=\"take\">Number of entities to take (for paging).</param>");
        sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <returns>Collection of {entityName} entities.</returns>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    Task<IEnumerable<{entityName}>> GetAllAsync(int? skip = null, int? take = null, CancellationToken cancellationToken = default);");
        sb.AppendLine();

        // GetFilteredAsync (if indexes exist)
        GenerateGetFilteredAsyncMethod(sb, table);

        // AddAsync
        sb.AppendLine("    /// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Adds a new {entityName} entity to the database.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <param name=\"entity\">The {entityName} entity to add.</param>");
        sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
        sb.AppendLine("    /// <returns>A task representing the asynchronous operation.</returns>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    Task AddAsync({entityName} entity, CancellationToken cancellationToken = default);");
        sb.AppendLine();

        // UpdateAsync
        sb.AppendLine("    /// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Updates an existing {entityName} entity in the database.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <param name=\"entity\">The {entityName} entity to update.</param>");
        sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
        sb.AppendLine("    /// <returns>A task representing the asynchronous operation.</returns>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    Task UpdateAsync({entityName} entity, CancellationToken cancellationToken = default);");
        sb.AppendLine();

        // DeleteAsync
        sb.AppendLine("    /// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Deletes a {entityName} entity from the database.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"id\">The primary key value of the entity to delete.</param>");
        sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
        sb.AppendLine("    /// <returns>A task representing the asynchronous operation.</returns>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    Task DeleteAsync({pkType} id, CancellationToken cancellationToken = default);");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates index-based query methods.
    /// </summary>
    private static void GenerateIndexBasedMethods(StringBuilder sb, Table table)
    {
        if (table.Indexes == null || table.Indexes.Count == 0)
        {
            return;
        }

        string entityName = table.Name;

        // Process each non-primary key index
        foreach (var index in table.Indexes.Where(i => !i.IsPrimaryKey))
        {
            if (index.ColumnNames == null || index.ColumnNames.Count == 0)
            {
                continue;
            }

            // Build method name from index columns using LINQ
            string methodName = "GetBy" + string.Join("And", index.ColumnNames.Select(CodeGenerationHelpers.SanitizeColumnName));

            // Build parameter list using LINQ
            var parameters = index.ColumnNames
                .Select(columnName => table.Columns.Find(c => c.Name == columnName))
                .Where(column => column != null)
                .Select(column => $"{GetCSharpType(column!.DataType)} {CodeGenerationHelpers.ToCamelCase(CodeGenerationHelpers.SanitizeColumnName(column.Name))}")
                .ToList();

            string paramList = string.Join(", ", parameters);

            // Generate method
            sb.AppendLine("    /// <summary>");
            if (index.IsUnique)
            {
                sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Gets a {entityName} entity by {string.Join(" and ", index.ColumnNames)}.");
                sb.AppendLine("    /// </summary>");

                // Generate param docs using LINQ
                var paramDocs = index.ColumnNames
                    .Select(columnName => table.Columns.Find(c => c.Name == columnName))
                    .Where(column => column != null)
                    .Select(column => (paramName: CodeGenerationHelpers.ToCamelCase(CodeGenerationHelpers.SanitizeColumnName(column!.Name)),
                                       sanitized: CodeGenerationHelpers.SanitizeColumnName(column.Name)));

                foreach (var (paramName, sanitized) in paramDocs)
                {
                    sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <param name=\"{paramName}\">The {sanitized} value to search for.</param>");
                }

                sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
                sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <returns>The {entityName} entity if found; otherwise, null.</returns>");
                sb.AppendLine(CultureInfo.InvariantCulture, $"    Task<{entityName}?> {methodName}Async({paramList}, CancellationToken cancellationToken = default);");
            }
            else
            {
                sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Gets all {entityName} entities matching the specified {string.Join(" and ", index.ColumnNames)}.");
                sb.AppendLine("    /// </summary>");

                // Generate param docs using LINQ
                var paramDocs = index.ColumnNames
                    .Select(columnName => table.Columns.Find(c => c.Name == columnName))
                    .Where(column => column != null)
                    .Select(column => (paramName: CodeGenerationHelpers.ToCamelCase(CodeGenerationHelpers.SanitizeColumnName(column!.Name)),
                                       sanitized: CodeGenerationHelpers.SanitizeColumnName(column.Name)));

                foreach (var (paramName, sanitized) in paramDocs)
                {
                    sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <param name=\"{paramName}\">The {sanitized} value to filter by.</param>");
                }

                sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
                sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <returns>Collection of {entityName} entities matching the criteria.</returns>");
                sb.AppendLine(CultureInfo.InvariantCulture, $"    Task<IEnumerable<{entityName}>> {methodName}Async({paramList}, CancellationToken cancellationToken = default);");
            }

            sb.AppendLine();
        }
    }

    /// <summary>
    /// Generates aggregate update methods for tables with agg_ columns.
    /// </summary>
    private static void GenerateAggregateMethods(StringBuilder sb, Table table)
    {
        // Find aggregate columns (agg_ prefix)
        var aggColumns = table.Columns
            .Where(c => c.Name.StartsWith("agg_", StringComparison.OrdinalIgnoreCase))
            .ToList();

        if (aggColumns.Count == 0)
        {
            return;
        }

        string entityName = table.Name;
        var pkColumn = table.Columns.Find(c => c.IsPrimaryKey);

        if (pkColumn == null)
        {
            return;
        }

        string pkType = GetCSharpType(pkColumn.DataType);

        // Build parameter list for aggregate columns using LINQ
        var parameters = new List<string> { $"{pkType} id" };
        parameters.AddRange(
            aggColumns.Select(column =>
                $"{GetCSharpType(column.DataType)} {CodeGenerationHelpers.ToCamelCase(CodeGenerationHelpers.SanitizeColumnName(column.Name))}"));

        string paramList = string.Join(", ", parameters);

        sb.AppendLine("    /// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Updates aggregate columns for a {entityName} entity.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <remarks>");
        sb.AppendLine("    /// <para>");
        sb.AppendLine("    /// Aggregate columns (agg_ prefix) store calculated values like counts and totals.");
        sb.AppendLine("    /// This method provides a dedicated way to update these values efficiently.");
        sb.AppendLine("    /// </para>");
        sb.AppendLine("    /// </remarks>");
        sb.AppendLine("    /// <param name=\"id\">The primary key value.</param>");

        // Generate param docs using LINQ
        var aggParamDocs = aggColumns.Select(column =>
            (paramName: CodeGenerationHelpers.ToCamelCase(CodeGenerationHelpers.SanitizeColumnName(column.Name)),
             sanitized: CodeGenerationHelpers.SanitizeColumnName(column.Name)));

        foreach (var (paramName, sanitized) in aggParamDocs)
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <param name=\"{paramName}\">New value for {sanitized}.</param>");
        }

        sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
        sb.AppendLine("    /// <returns>A task representing the asynchronous operation.</returns>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    Task UpdateAggregatesAsync({paramList}, CancellationToken cancellationToken = default);");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates GetFilteredAsync method based on table indexes.
    /// </summary>
    private static void GenerateGetFilteredAsyncMethod(StringBuilder sb, Table table)
    {
        var filterableIndexes = table.Indexes?
            .Where(i => !i.IsPrimaryKey && i.ColumnNames != null && i.ColumnNames.Count > 0)
            .ToList();

        if (filterableIndexes == null || filterableIndexes.Count == 0)
        {
            // No filterable indexes, skip
            return;
        }

        string entityName = table.Name;
        var parameters = new List<(string paramName, string paramType, string columnName)>();

        // Collect unique indexed columns
        var processedColumns = new HashSet<string>();
        foreach (var index in filterableIndexes)
        {
            foreach (var columnName in index.ColumnNames)
            {
                if (!processedColumns.Contains(columnName))
                {
                    processedColumns.Add(columnName);
                    var column = table.Columns.FirstOrDefault(c => c.Name == columnName);
                    if (column != null)
                    {
                        string paramName = CodeGenerationHelpers.ToCamelCase(CodeGenerationHelpers.SanitizeColumnName(columnName));
                        string paramType = GetCSharpType(column.DataType) + "?"; // Nullable
                        parameters.Add((paramName, paramType, columnName));
                    }
                }
            }
        }

        if (parameters.Count == 0)
        {
            return;
        }

        // XML Documentation
        sb.AppendLine("    /// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Gets filtered {entityName} entities based on indexed columns.");
        sb.AppendLine("    /// </summary>");

        foreach (var (paramName, _, columnName) in parameters)
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <param name=\"{paramName}\">Filter by {columnName} (optional).</param>");
        }

        sb.AppendLine("    /// <param name=\"skip\">Number of entities to skip (for paging).</param>");
        sb.AppendLine("    /// <param name=\"take\">Number of entities to take (for paging).</param>");
        sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <returns>Collection of filtered {entityName} entities.</returns>");

        // Method signature
        var paramList = string.Join(", ",
            parameters.Select(p => $"{p.paramType} {p.paramName} = null")
            .Concat(new[] { "int? skip = null", "int? take = null", "CancellationToken cancellationToken = default" }));

        sb.AppendLine(CultureInfo.InvariantCulture, $"    Task<IEnumerable<{entityName}>> GetFilteredAsync({paramList});");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates helper methods like ExistsAsync.
    /// </summary>
    private static void GenerateHelperMethods(StringBuilder sb, Table table)
    {
        string entityName = table.Name;
        var pkColumn = table.Columns.Find(c => c.IsPrimaryKey);

        if (pkColumn == null)
        {
            return;
        }

        string pkType = GetCSharpType(pkColumn.DataType);

        // ExistsAsync
        sb.AppendLine("    /// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Checks if a {entityName} entity exists with the specified primary key.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"id\">The primary key value to check.</param>");
        sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token.</param>");
        sb.AppendLine("    /// <returns>True if the entity exists; otherwise, false.</returns>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    Task<bool> ExistsAsync({pkType} id, CancellationToken cancellationToken = default);");
    }

    /// <summary>
    /// Closes the interface declaration.
    /// </summary>
    private static void CloseInterface(StringBuilder sb)
    {
        sb.AppendLine("}");
    }

    /// <summary>
    /// Maps SQL data types to C# types.
    /// </summary>
    private static string GetCSharpType(string sqlType)
    {
        return sqlType.ToUpperInvariant() switch
        {
            "INT" => "int",
            "BIGINT" => "long",
            "SMALLINT" => "short",
            "TINYINT" => "byte",
            "BIT" => "bool",
            "DECIMAL" or "NUMERIC" or "MONEY" or "SMALLMONEY" => "decimal",
            "FLOAT" => "double",
            "REAL" => "float",
            "DATETIME" or "DATETIME2" or "DATE" or "SMALLDATETIME" => "DateTime",
            "TIME" => "TimeSpan",
            "DATETIMEOFFSET" => "DateTimeOffset",
            "UNIQUEIDENTIFIER" => "Guid",
            "VARCHAR" or "NVARCHAR" or "CHAR" or "NCHAR" or "TEXT" or "NTEXT" => "string",
            "VARBINARY" or "BINARY" or "IMAGE" => "byte[]",
            _ => "string"
        };
    }
}
