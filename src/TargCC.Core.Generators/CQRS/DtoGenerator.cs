// <copyright file="DtoGenerator.cs" company="PlaceholderCompany">
// Copyright (c) PlaceholderCompany. All rights reserved.
// </copyright>

namespace TargCC.Core.Generators.CQRS;

using System.Globalization;
using System.Text;
using Microsoft.Extensions.Logging;
using TargCC.Core.Interfaces.Models;

/// <summary>
/// Generates Data Transfer Object (DTO) classes for entities.
/// </summary>
/// <remarks>
/// <para>
/// The DtoGenerator creates type-safe DTOs optimized for different scenarios:
/// </para>
/// <list type="bullet">
/// <item><description>Basic - Standard DTO with safe properties</description></item>
/// <item><description>List - Minimal DTO for lists/grids</description></item>
/// <item><description>Detail - Complete DTO with all details</description></item>
/// <item><description>Create - Input DTO for creation</description></item>
/// <item><description>Update - Input DTO for updates</description></item>
/// </list>
/// </remarks>
public class DtoGenerator : IDtoGenerator
{
    private static readonly HashSet<string> SensitivePrefixes = new (StringComparer.OrdinalIgnoreCase)
    {
        "eno_", // Hashed (one-way encryption)
        "ent_", // Encrypted (two-way encryption)
    };

    private static readonly HashSet<string> ComputedPrefixes = new (StringComparer.OrdinalIgnoreCase)
    {
        "clc_", // Calculated
        "agg_", // Aggregate
        "blg_", // Business Logic (server-side)
    };

    private static readonly HashSet<string> AutoGeneratedColumns = new (StringComparer.OrdinalIgnoreCase)
    {
        "ID",
        "AddedOn",
        "AddedBy",
        "ChangedOn",
        "ChangedBy",
        "RowVersion",
        "CreatedAt",
        "UpdatedAt",
        "CreatedBy",
        "UpdatedBy",
    };

    private static readonly Action<ILogger, DtoType, string, Exception?> LogGenerating =
        LoggerMessage.Define<DtoType, string>(
            LogLevel.Debug,
            new EventId(1, nameof(GenerateAsync)),
            "Generating {DtoType} DTO for table {TableName}");

    private static readonly Action<ILogger, DtoType, string, int, Exception?> LogGenerated =
        LoggerMessage.Define<DtoType, string, int>(
            LogLevel.Information,
            new EventId(2, nameof(GenerateAsync)),
            "Generated {DtoType} DTO '{ClassName}' with {PropertyCount} properties");

    private static readonly Action<ILogger, string, Exception?> LogGeneratingAll =
        LoggerMessage.Define<string>(
            LogLevel.Debug,
            new EventId(3, nameof(GenerateAllAsync)),
            "Generating all DTO types for table {TableName}");

    private static readonly Action<ILogger, int, string, Exception?> LogGeneratedAll =
        LoggerMessage.Define<int, string>(
            LogLevel.Information,
            new EventId(4, nameof(GenerateAllAsync)),
            "Generated {Count} DTOs for table {TableName}");

    private readonly ILogger<DtoGenerator> _logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="DtoGenerator"/> class.
    /// </summary>
    /// <param name="logger">The logger instance for diagnostic output.</param>
    /// <exception cref="ArgumentNullException">Thrown when logger is null.</exception>
    public DtoGenerator(ILogger<DtoGenerator> logger)
    {
        ArgumentNullException.ThrowIfNull(logger);
        _logger = logger;
    }

    /// <inheritdoc/>
    public async Task<DtoGenerationResult> GenerateAsync(Table table, DtoType dtoType)
    {
        ArgumentNullException.ThrowIfNull(table);

        LogGenerating(_logger, dtoType, table.Name, null);

        var properties = GetPropertiesForDtoType(table, dtoType);
        var className = GetDtoClassName(table.Name, dtoType);
        var code = GenerateDtoCode(table, dtoType, className, properties);

        LogGenerated(_logger, dtoType, className, properties.Count, null);

        return await Task.FromResult(new DtoGenerationResult
        {
            Code = code,
            ClassName = className,
            DtoType = dtoType,
            Namespace = $"TargCC.Application.Features.{table.Name}s.Dtos",
            Properties = properties,
        });
    }

    /// <inheritdoc/>
    public async Task<IEnumerable<DtoGenerationResult>> GenerateAllAsync(Table table)
    {
        ArgumentNullException.ThrowIfNull(table);

        LogGeneratingAll(_logger, table.Name, null);

        var results = new List<DtoGenerationResult>();

        foreach (DtoType dtoType in Enum.GetValues<DtoType>())
        {
            var result = await GenerateAsync(table, dtoType);
            results.Add(result);
        }

        LogGeneratedAll(_logger, results.Count, table.Name, null);

        return results;
    }

    /// <inheritdoc/>
    public IReadOnlyList<string> GetPropertiesForDtoType(Table table, DtoType dtoType)
    {
        ArgumentNullException.ThrowIfNull(table);

        var columns = table.Columns?.ToList() ?? new List<Column>();

        return dtoType switch
        {
            DtoType.Basic => GetBasicProperties(columns),
            DtoType.List => GetListProperties(columns),
            DtoType.Detail => GetDetailProperties(columns),
            DtoType.Create => GetCreateProperties(columns),
            DtoType.Update => GetUpdateProperties(columns),
            _ => GetBasicProperties(columns),
        };
    }

    /// <inheritdoc/>
    public bool IsSensitiveColumn(string columnName)
    {
        if (string.IsNullOrEmpty(columnName))
        {
            return false;
        }

        return SensitivePrefixes.Any(prefix =>
            columnName.StartsWith(prefix, StringComparison.OrdinalIgnoreCase));
    }

    private static string GetDtoClassName(string tableName, DtoType dtoType)
    {
        return dtoType switch
        {
            DtoType.Basic => $"{tableName}Dto",
            DtoType.List => $"{tableName}ListDto",
            DtoType.Detail => $"{tableName}DetailDto",
            DtoType.Create => $"Create{tableName}Dto",
            DtoType.Update => $"Update{tableName}Dto",
            _ => $"{tableName}Dto",
        };
    }

    private static string GenerateDtoCode(Table table, DtoType dtoType, string className, IReadOnlyList<string> propertyNames)
    {
        var sb = new StringBuilder();

        // Header
        sb.AppendLine(CultureInfo.InvariantCulture, $"// <auto-generated>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"// This code was generated by TargCC DtoGenerator.");
        sb.AppendLine(CultureInfo.InvariantCulture, $"// Generated at: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
        sb.AppendLine(CultureInfo.InvariantCulture, $"// Source Table: {table.Name}");
        sb.AppendLine(CultureInfo.InvariantCulture, $"// DTO Type: {dtoType}");
        sb.AppendLine(CultureInfo.InvariantCulture, $"// </auto-generated>");
        sb.AppendLine();

        // Namespace and usings
        sb.AppendLine(CultureInfo.InvariantCulture, $"namespace TargCC.Application.Features.{table.Name}s.Dtos;");
        sb.AppendLine();

        // Class documentation
        sb.AppendLine(CultureInfo.InvariantCulture, $"/// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"/// {GetDtoDescription(dtoType, table.Name)}");
        sb.AppendLine(CultureInfo.InvariantCulture, $"/// </summary>");

        // Class declaration
        sb.AppendLine(CultureInfo.InvariantCulture, $"public class {className}");
        sb.AppendLine("{");

        // Generate properties
        var columns = table.Columns?.Where(c => propertyNames.Contains(c.Name)).ToList()
            ?? new List<Column>();

        foreach (var column in columns)
        {
            GenerateProperty(sb, column, dtoType);
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string GetDtoDescription(DtoType dtoType, string tableName)
    {
        return dtoType switch
        {
            DtoType.Basic => $"Data transfer object for {tableName} entity.",
            DtoType.List => $"Minimal data transfer object for {tableName} list views.",
            DtoType.Detail => $"Detailed data transfer object for {tableName} with all properties.",
            DtoType.Create => $"Input data transfer object for creating a new {tableName}.",
            DtoType.Update => $"Input data transfer object for updating an existing {tableName}.",
            _ => $"Data transfer object for {tableName}.",
        };
    }

    private static void GenerateProperty(StringBuilder sb, Column column, DtoType dtoType)
    {
        var propertyName = SanitizeColumnName(column.Name);
        var propertyType = GetCSharpType(column);
        var accessModifier = dtoType == DtoType.Create || dtoType == DtoType.Update ? "set" : "init";
        var defaultValue = GetDefaultValue(column, propertyType);

        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// <summary>");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// Gets or sets the {propertyName.ToUpperInvariant()} value.");
        sb.AppendLine(CultureInfo.InvariantCulture, $"    /// </summary>");

        if (!string.IsNullOrEmpty(defaultValue))
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"    public {propertyType} {propertyName} {{ get; {accessModifier}; }} = {defaultValue};");
        }
        else
        {
            sb.AppendLine(CultureInfo.InvariantCulture, $"    public {propertyType} {propertyName} {{ get; {accessModifier}; }}");
        }

        sb.AppendLine();
    }

    private static bool IsComputedColumn(string columnName)
    {
        return ComputedPrefixes.Any(prefix =>
            columnName.StartsWith(prefix, StringComparison.OrdinalIgnoreCase));
    }

    private static bool IsAutoGeneratedColumn(string columnName)
    {
        return AutoGeneratedColumns.Contains(columnName);
    }

    private static bool IsAutoGeneratedTimestamp(string columnName)
    {
        HashSet<string> timestampColumns = new (StringComparer.OrdinalIgnoreCase)
        {
            "AddedOn", "AddedBy", "ChangedOn", "ChangedBy",
            "CreatedAt", "UpdatedAt", "CreatedBy", "UpdatedBy",
        };
        return timestampColumns.Contains(columnName);
    }

    private static bool IsListColumn(Column column)
    {
        // Include columns that are likely display fields
        string[] displayIndicators = new[] { "name", "title", "code", "status", "type", "email" };

        var upperName = column.Name.ToUpperInvariant();

        // Always include primary key
        if (column.IsPrimaryKey)
        {
            return true;
        }

        // Include if matches display indicators
        if (Array.Exists(displayIndicators, indicator => upperName.Contains(indicator.ToUpperInvariant(), StringComparison.OrdinalIgnoreCase)))
        {
            return true;
        }

        // Include foreign keys (for reference)
        if (column.IsForeignKey)
        {
            return true;
        }

        // Exclude long text fields
        if (column.MaxLength.HasValue && column.MaxLength.Value > 500)
        {
            return false;
        }

        return false;
    }

    private static string SanitizeColumnName(string columnName)
    {
        // Remove TargCC prefixes
        string[] prefixes = new[] { "eno_", "ent_", "lkp_", "enm_", "loc_", "clc_", "blg_", "agg_", "spt_", "upl_", "scb_", "spl_" };

        var matchingPrefix = Array.Find(prefixes, prefix => columnName.StartsWith(prefix, StringComparison.OrdinalIgnoreCase));
        if (matchingPrefix != null)
        {
            columnName = columnName[matchingPrefix.Length..];
        }

        // Ensure PascalCase
        if (columnName.Length > 0)
        {
            columnName = char.ToUpper(columnName[0], CultureInfo.InvariantCulture) + columnName[1..];
        }

        return columnName;
    }

    private static string GetCSharpType(Column column)
    {
        var baseType = column.DataType?.ToUpperInvariant() switch
        {
            "INT" => "int",
            "BIGINT" => "long",
            "SMALLINT" => "short",
            "TINYINT" => "byte",
            "BIT" => "bool",
            "DECIMAL" or "NUMERIC" or "MONEY" or "SMALLMONEY" => "decimal",
            "FLOAT" => "double",
            "REAL" => "float",
            "DATETIME" or "DATETIME2" or "SMALLDATETIME" or "DATE" => "DateTime",
            "DATETIMEOFFSET" => "DateTimeOffset",
            "TIME" => "TimeSpan",
            "UNIQUEIDENTIFIER" => "Guid",
            "CHAR" or "NCHAR" or "VARCHAR" or "NVARCHAR" or "TEXT" or "NTEXT" => "string",
            "BINARY" or "VARBINARY" or "IMAGE" => "byte[]",
            "XML" => "string",
            _ => "string",
        };

        // Add nullable marker if column is nullable (except for reference types)
        if (column.IsNullable && baseType != "string" && baseType != "byte[]")
        {
            baseType += "?";
        }

        return baseType;
    }

    private static string GetDefaultValue(Column column, string propertyType)
    {
        if (propertyType == "string" && !column.IsNullable)
        {
            return "string.Empty";
        }

        if (propertyType == "byte[]" && !column.IsNullable)
        {
            return "Array.Empty<byte>()";
        }

        return string.Empty;
    }

    private List<string> GetBasicProperties(List<Column> columns)
    {
        return columns
            .Where(c => !IsSensitiveColumn(c.Name))
            .Where(c => !IsComputedColumn(c.Name))
            .Select(c => c.Name)
            .ToList();
    }

    private List<string> GetListProperties(List<Column> columns)
    {
        // For list DTOs, include only key identifiers and display fields
        var listColumns = columns
            .Where(c => !IsSensitiveColumn(c.Name))
            .Where(c => !IsComputedColumn(c.Name))
            .Where(c => IsListColumn(c))
            .Select(c => c.Name)
            .ToList();

        // Always include ID if present
        var idColumn = columns.Find(c =>
            c.Name.Equals("ID", StringComparison.OrdinalIgnoreCase) ||
            c.IsPrimaryKey);

        if (idColumn != null && !listColumns.Contains(idColumn.Name))
        {
            listColumns.Insert(0, idColumn.Name);
        }

        return listColumns;
    }

    private List<string> GetDetailProperties(List<Column> columns)
    {
        // Detail DTO includes everything except sensitive columns
        return columns
            .Where(c => !IsSensitiveColumn(c.Name))
            .Select(c => c.Name)
            .ToList();
    }

    private List<string> GetCreateProperties(List<Column> columns)
    {
        return columns
            .Where(c => !IsSensitiveColumn(c.Name))
            .Where(c => !IsComputedColumn(c.Name))
            .Where(c => !IsAutoGeneratedColumn(c.Name))
            .Where(c => !c.IsPrimaryKey || !c.IsIdentity) // Exclude auto-increment PKs
            .Select(c => c.Name)
            .ToList();
    }

    private List<string> GetUpdateProperties(List<Column> columns)
    {
        var updateColumns = columns
            .Where(c => !IsSensitiveColumn(c.Name))
            .Where(c => !IsComputedColumn(c.Name))
            .Where(c => !IsAutoGeneratedTimestamp(c.Name))
            .Select(c => c.Name)
            .ToList();

        // Always include ID for updates
        var idColumn = columns.Find(c =>
            c.Name.Equals("ID", StringComparison.OrdinalIgnoreCase) ||
            c.IsPrimaryKey);

        if (idColumn != null && !updateColumns.Contains(idColumn.Name))
        {
            updateColumns.Insert(0, idColumn.Name);
        }

        return updateColumns;
    }
}
